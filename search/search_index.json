{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bem vindo","text":""},{"location":"#monkeys-ufg","title":"Monkeys UFG","text":"<p>Bem-vindo ao site do Grupo de Programa\u00e7\u00e3o Competitiva da Universidade Federal de Goi\u00e1s (UFG)!</p> <p>Este site tem como objetivo ser um guia para estudantes interessados em participar de competi\u00e7\u00f5es de programa\u00e7\u00e3o, como a Olimp\u00edada Brasileira de Inform\u00e1tica (OBI), a Maratona SBC de Programa\u00e7\u00e3o, Maratona Feminina de Programa\u00e7\u00e3o, entre outras. Aqui, voc\u00ea encontrar\u00e1 uma cole\u00e7\u00e3o de artigos elaborados por nossos membros, al\u00e9m de diversas refer\u00eancias para o aprendizado dos t\u00f3picos mais relevantes da programa\u00e7\u00e3o competitiva.</p>"},{"location":"#secoes-do-site","title":"Se\u00e7\u00f5es do Site:","text":"<p>Blog: Fique por dentro das novidades, conquistas e eventos do grupo Monkeys.</p> <p>Iniciando na OBI/Maratona: Um guia completo para estudantes que querem come\u00e7ar a participar das competi\u00e7\u00f5es de programa\u00e7\u00e3o!</p> <p>Biblioteca: Biblioteca com implementa\u00e7\u00f5es de algoritmos utilizadas pelo grupo Monkeys.</p> <p>Sites: Conhe\u00e7a os principais sites para programa\u00e7\u00e3o competitiva e como aproveit\u00e1-los ao m\u00e1ximo.</p> <p>Membros: Conhe\u00e7a os integrantes do grupo Monkeys e suas contribui\u00e7\u00f5es.</p>"},{"location":"#duvidas","title":"D\u00favidas?","text":"<p>Se voc\u00ea tiver alguma d\u00favida, n\u00e3o hesite em entrar em contato conosco!</p> <p>Na UFG: Laborat\u00f3rio 252 - INF</p> <p>Online:</p> <p> </p>"},{"location":"members/","title":"Em breve...","text":""},{"location":"blog/","title":"Blog","text":""},{"location":"blog/grupo-com-simulados-da-obi/","title":"Grupo com Simulados da OBI","text":"<p>Ol\u00e1!</p> <p>N\u00f3s criamos um grupo no Codeforces onde \u00e9 poss\u00edvel simular as fases anteriores da OBI. Se voc\u00ea nunca utilizou o Codeforces e quer orienta\u00e7\u00f5es de como utiliz\u00e1-lo, voc\u00ea pode obter mais informa\u00e7\u00f5es aqui.</p>"},{"location":"blog/introdu%C3%A7%C3%A3o-aos-conceitos-de-programa%C3%A7%C3%A3o-competitiva-icpc/","title":"Introdu\u00e7\u00e3o aos Conceitos de Programa\u00e7\u00e3o Competitiva (ICPC)","text":"<p>Est\u00e3o abertas as pr\u00e9-matr\u00edculas para a disciplina ICPC!</p> <p>A Disciplina acontecer\u00e1 na Quarta-Feira das 14h00 as 17h40, sendo uma mat\u00e9ria de N\u00facleo Livre. O formul\u00e1rio de inscri\u00e7\u00e3o pode ser encontrado aqui, com prazo para o preenchimento at\u00e9 23h59 04/08/2025</p> <p>Nesta disciplina ser\u00e3o ensinados conceitos essenciais de programac\u0327a\u0303o focados em olimpi\u0301adas de inform\u00e1tica, abordando to\u0301picos como: </p> <ul> <li>T\u00e9cnicas de Programa\u00e7\u00e3o (For\u00e7a Bruta, Busca Bin\u00e1ria, Two pointers, Programa\u00e7\u00e3o Din\u00e2mica),</li> <li>Algoritmos (Algoritmos de Grafos e de Processamento de Strings) e </li> <li>Estruturas de Dados (\u00c1rvore de Segmentos,  \u00c1rvore de Fenwick, Estruturas da STL/C++).</li> </ul> <p>As aulas incluem teoria, exemplos pra\u0301ticos e listas de exerci\u0301cios.</p> <p>Como a disciplina segue um formato incomum, o m\u00e9todo de prioridade para selecionar participantes tamb\u00e9m \u00e9 incomum com rela\u00e7\u00e3o ao padr\u00e3o. A prioridade ser\u00e1 para alunos no inicio da gradua\u00e7\u00e3o (quatro primeiros per\u00edodos), dando prioridade para alunos que j\u00e1 participaram de eventos correlatos.</p>"},{"location":"blog/monkeys-contest---selection-edition/","title":"Monkeys Contest - Selection Edition","text":"<p>A Primeira Fase da Maratona de Programa\u00e7\u00e3o est\u00e1 chegando! Caso voc\u00ea tenha interesse em participar, inscreva-se neste formul\u00e1rio para participar da nossa seletiva. </p> <p>Todos os alunos da UFG podem participar, e \u00e9 uma \u00f3tima oportunidade para se divertir e se desafiar! Estamos preparando \u00f3timos problemas para que todos possam praticar com os desafios de programa\u00e7\u00e3o!</p> <p>A competi\u00e7\u00e3o ocorrer\u00e1 no dia 16/08/2025 e ter\u00e1 uma dura\u00e7\u00e3o de 5h, come\u00e7ando as 13h. Ser\u00e1 utilizada a plataforma BOCA.</p> <p>O regulamento para a sele\u00e7\u00e3o de equipes da UFG est\u00e1 neste link.</p> <p>Para mais informa\u00e7\u00f5es nos pergunte via discord ou e-mail monkeysufg@gmail.com. Caso voc\u00ea n\u00e3o tenha uma equipe o discord pode ser um bom ambiente para encontrar outras pessoas interessadas.</p>"},{"location":"library/note/","title":"Em breve...","text":""},{"location":"sites/atcoder/","title":"AtCoder","text":"<p>O AtCoder \u00e9 um site japon\u00eas focado em programa\u00e7\u00e3o competitiva, sendo considerado uma das principais plataformas da \u00e1rea no mundo.</p>"},{"location":"sites/atcoder/#tipos-de-competicoes","title":"Tipos de Competi\u00e7\u00f5es","text":"<p>O AtCoder organiza tr\u00eas tipos principais de competi\u00e7\u00f5es semanais:</p> <ul> <li>Beginner Contest (ABC): Voltado para iniciantes, \u00e9 ideal para praticar os fundamentos de algoritmos e estruturas de dados.</li> <li>Regular Contest (ARC): De dificuldade intermedi\u00e1ria, \u00e9 indicado para quem j\u00e1 possui alguma experi\u00eancia em competi\u00e7\u00f5es de programa\u00e7\u00e3o.</li> <li>Grand Contest (AGC): \u00c9 o mais desafiador dos tr\u00eas e geralmente inclui problemas complexos que exigem criatividade e o dom\u00ednio de t\u00e9cnicas avan\u00e7adas.</li> </ul> <p>Essas competi\u00e7\u00f5es s\u00e3o abertas, cronometradas e possuem um ranking oficial, o que contribui para a reputa\u00e7\u00e3o do usu\u00e1rio dentro da comunidade.</p> <p>Voc\u00ea pode encontrar todas as competi\u00e7\u00f5es passadas do AtCoder na aba de contests:</p> <p>https://atcoder.jp/contests/</p>"},{"location":"sites/atcoder/#sistema-de-pontuacao-e-ranqueamento","title":"Sistema de Pontua\u00e7\u00e3o e Ranqueamento","text":"<p>Cada usu\u00e1rio possui um rating, uma pontua\u00e7\u00e3o que varia conforme o desempenho nas competi\u00e7\u00f5es. Esse sistema permite que voc\u00ea acompanhe seu progresso e se compare com outros competidores ao redor do mundo.</p>"},{"location":"sites/atcoder/#afiliacao-com-a-ufg","title":"Afilia\u00e7\u00e3o com a UFG","text":"<p>Ap\u00f3s criar sua conta no AtCoder, voc\u00ea pode se afiliar aos competidores da UFG que tamb\u00e9m utilizam o site. Para isso, acesse as configura\u00e7\u00f5es gerais do seu perfil e, no campo Affiliation, preencha com \"UFG\".</p> <p>Isso permite que voc\u00ea filtre o ranking para visualizar apenas os participantes da UFG, tanto em classifica\u00e7\u00f5es gerais quanto durante as competi\u00e7\u00f5es.</p>"},{"location":"sites/atcoder/#contests-classicos","title":"Contests Cl\u00e1ssicos","text":"<p>O AtCoder oferece contests cl\u00e1ssicos focados em t\u00f3picos essenciais para competi\u00e7\u00f5es de programa\u00e7\u00e3o. Dois deles se destacam:</p> <ul> <li> <p>AtCoder Educational DP Contest: Um conjunto de problemas dedicado \u00e0 Programa\u00e7\u00e3o Din\u00e2mica, uma das t\u00e9cnicas mais importantes da \u00e1rea.</p> </li> <li> <p>AtCoder Library Practice Contest: Um contest voltado para a pr\u00e1tica e teste de estruturas de dados amplamente utilizadas.</p> </li> </ul> <p>Esses contests s\u00e3o excelentes recursos para aprender e validar suas implementa\u00e7\u00f5es das t\u00e9cnicas e estruturas de dados mais comuns em programa\u00e7\u00e3o competitiva.</p>"},{"location":"sites/atcoder/#kenkooooatcoder-problems","title":"kenkoooo/atcoder-problems","text":"<p>O kenkoooo/atcoder \u00e9 uma ferramenta interativa para praticar problemas do AtCoder. Ela exibe uma tabela com todos os problemas j\u00e1 lan\u00e7ados, mostrando:</p> <ul> <li>Quais voc\u00ea j\u00e1 resolveu (marcados em verde).</li> <li>A dificuldade estimada de cada problema.</li> <li>Filtros por dificuldade, tipo de contest (ABC, ARC, AGC) e status (resolvido ou n\u00e3o resolvido).</li> </ul> <p>Voc\u00ea pode fazer login com seu usu\u00e1rio do AtCoder para acompanhar seu progresso automaticamente. \u00c9 uma ferramenta ideal para estudar de forma organizada e escolher problemas adequados ao seu n\u00edvel de habilidade.</p>"},{"location":"sites/codeforces/","title":"Codeforces","text":""},{"location":"sites/cpalgo/","title":"CP-Algorithms","text":""},{"location":"sites/cses/","title":"CSES","text":"<p>O CSES (Code Submission Evaluation System) \u00e9 um judge finland\u00eas com centenas de problemas relacionados a programa\u00e7\u00e3o dos mais variados t\u00f3picos, onde os problemas tendem a ser mais cl\u00e1ssicos, o que \u00e9 perfeito para quem estiver come\u00e7ando na jornada de programa\u00e7\u00e3o competitiva.</p> <p>Ele separa os t\u00f3picos em v\u00e1rias sess\u00f5es para direcionar melhor o que \u00e9 necess\u00e1rio aprender em cada sess\u00e3o. Al\u00e9m disso, o site possui um livro texto. O livro \u00e9 bastante interessante, pois serve como um guia para aprender a linguagem C++, usada amplamente no contexto de Programa\u00e7\u00e3o Competitiva, e tamb\u00e9m serve como um guia para resolver os problemas dados como exerc\u00edcios no site. \u00c9 interessante usar o livro e os recursos apresentados nesse site para resolver os problemas propostos, mas lembre-se que o livro \u00e9 apenas um guia, ent\u00e3o h\u00e1 v\u00e1rias coisas que uma pessoa pode aprender sobre um problema se ela dedicar um tempo tentando resolv\u00ea-los antes.</p> <p>O site atualmente conta com \\(400\\) problemas diferentes, dos mais variados n\u00edveis de dificuldade, e voc\u00ea pode resolv\u00ea-los em qualquer ordem que desejar. Assim, se voc\u00ea se sentir perdido em algum problema, voc\u00ea pode ir para o pr\u00f3ximo para esfriar sua cabe\u00e7a do problema atual, e voltar nele depois para enfim poder resolv\u00ea-lo. \u00c9 um site interessante para se aprender e \u00e9 interessante dedicar um pouco do seu treinamento nas listas de problemas que ele tem a oferecer.</p>"},{"location":"sites/usaco/","title":"USACO Guide","text":""},{"location":"start/binarysearch/","title":"Busca Bin\u00e1ria","text":""},{"location":"start/binarysearch/#aula-relacionada-recomendada","title":"Aula Relacionada Recomendada:","text":"C\u0155editos: Canal Maratona UFMG."},{"location":"start/binarysearch/#motivacao","title":"Motiva\u00e7\u00e3o","text":"<p>Pense no seguinte problema</p> <p>Uma f\u00e1brica possui \\(n \\) m\u00e1quinas que podem ser utilizadas para fabricar produtos. Seu objetivo \u00e9 produzir um total de \\(t \\) produtos.</p> <p>Para cada m\u00e1quina, voc\u00ea sabe quantos segundos ela leva para fabricar um \u00fanico produto. As m\u00e1quinas podem trabalhar simultaneamente, e voc\u00ea pode definir livremente o cronograma de produ\u00e7\u00e3o. Qual \u00e9 o menor tempo necess\u00e1rio para produzir \\(t \\) produtos?</p> <p>CSES - Factory Machines</p> <p>Nota</p> <p>Tente resolver o problema antes de continuar a leitura.</p>"},{"location":"start/binarysearch/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>O conceito de busca bin\u00e1ria surge quando buscamos encontrar valores em um determinado conjunto de forma r\u00e1pida e eficiente.</p> <p>Suponha que queiramos encontrar um elemento em um determinado array. Uma abordagem gen\u00e9rica consiste em usar um la\u00e7o <code>for</code> e percorrer todos os seus elementos.</p> <p>Uma poss\u00edvel implementa\u00e7\u00e3o dessa busca \u00e9 a seguinte:</p> <p>search.cpp<pre><code>for (int i = 0; i &lt; N; i++) {\n  if (array[i] == x) {\n    // elemento x encontrado no indice i;\n    cout &lt;&lt; \"ELEMENTO ENCONTRADO!\\n\";\n    break;\n  }\n}\n</code></pre> Essa abordagem, por sua vez, tem complexidade \\(\\mathcal{O}(N) \\) no pior caso. Agora, suponha que desejemos realizar \\(Q \\) consultas de elementos. Nesse cen\u00e1rio, a complexidade torna-se \\(\\mathcal{O}(NQ) \\), o que \u00e9 invi\u00e1vel quando \\(N \\) e \\(Q \\) s\u00e3o da ordem de \\(10^5 \\).</p> <p>No entanto, h\u00e1 uma propriedade interessante: se os elementos do vetor estiverem ordenados, cada busca pode ser feita em \\(\\mathcal{O}(\\log_2(N)) \\).</p> <p>Na busca bin\u00e1ria, escolhemos o elemento do meio do intervalo e, a cada itera\u00e7\u00e3o, decidimos se o pr\u00f3ximo intervalo de busca ficar\u00e1 \u00e0 direita ou \u00e0 esquerda desse ponto, com base no valor do elemento que buscamos.</p> <p>A ideia pode ser vizualizada a seguir:</p> 1/1 \u276e \u276f <p></p> <p>A ideia apresentada anteriormente pode ser implementada da seguinte maneira:</p> <p>binarysearch.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n  // n: n\u00famero de elementos do vetor\n  // q: n\u00famero de consultas realizadas\n  int n, q;\n  cin &gt;&gt; n &gt;&gt; q;\n  vector&lt;int&gt; a(n);\n  for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; // O(n)\n\n  // ordenamos o vetor para que seja poss\u00edvel aplicar a b\u00fasca bin\u00e1ria\n  sort(a.begin(), a.end()); // O(n log n)\n\n  while(q--) {\n    // para cada consulta, buscamos o elemento x\n    int x; cin &gt;&gt; x;\n\n    // inicialmente nosso espa\u00e7o de busca \u00e9 todo o array.\n    // iniciamos find com false para que possamos identifcar facilmente  \n    // o caso em que o elemento n\u00e3o existe no array.\n    int left = 0, right = n - 1;\n    bool find = false;\n    while (left &lt;= right) {\n      int mid = (left + right) / 2;\n\n      if (a[mid] == x) {\n        find = true;\n        break;\n      } else if (a[mid] &lt; x) left = mid + 1;\n      else right = mid - 1;\n    }\n    cout &lt;&lt; (find ? \"SIM\\n\" : \"NAO\\n\");\n  } // O(q log n)\n\n  return 0;\n}\n</code></pre> Complexidade final: \\(\\mathcal{O}(N\\cdot \\log_2 (N)) \\)</p>"},{"location":"start/binarysearch/#busca-binaria-em-funcoes-monotonas","title":"Busca Bin\u00e1ria em Fun\u00e7\u00f5es mon\u00f3tonas","text":"<p>Para al\u00e9m da simples busca de elementos, a t\u00e9cnica de busca bin\u00e1ria pode ser aplicada na resolu\u00e7\u00e3o de problemas de minimiza\u00e7\u00e3o e maximiza\u00e7\u00e3o.</p> <p>Considere uma fun\u00e7\u00e3o booleana \\(f(x) \\). Em problemas desse tipo, queremos determinar o menor (ou maior) valor de \\(x \\) para o qual \\(f(x) \\) retorna verdadeiro. Para que isso seja poss\u00edvel de forma eficiente, \u00e9 fundamental que \\(f \\) seja mon\u00f3tona. Sob essa condi\u00e7\u00e3o, todos os pontos em que \\(f(x) = true \\) aparecem agrupados em um \u00fanico intervalo cont\u00edguo.</p> <p>Ou seja: </p> <p>Para fun\u00e7\u00f5es crescente, existe um ponto de corte \\(x'\\) tal que</p> \\[   f(x) =   \\begin{cases}   \\mathtt{false}, &amp; x &lt; x',\\\\   \\mathtt{true},  &amp; x \\ge x'.   \\end{cases} \\] <p>Para fun\u00e7\u00f5es decrescente, o padr\u00e3o \u00e9 an\u00e1logo, mas com os valores invertidos:</p> \\[   f(x) =   \\begin{cases}   \\mathtt{true},  &amp; x &lt; x',\\\\   \\mathtt{false}, &amp; x \\ge x'.   \\end{cases} \\] <p>Podemos usar essa propriedade para resolver o problema motivador.</p>"},{"location":"start/binarysearch/#solucao","title":"Solu\u00e7\u00e3o:","text":"<p>O objetivo \u00e9 descobrir o menor tempo necess\u00e1rio para produzir uma quantidade \\(t\\) de produtos. Podemos converter isso em um problema de minimiza\u00e7\u00e3o definindo uma fun\u00e7\u00e3o booleana</p> \\[   f(X, t) =    \\begin{cases}   \\mathtt{true}, &amp; \\text X\\text{ segundos \u00e9 suficiente produzir pelo menos }t\\text{ produtos}.\\\\   \\mathtt{false}, &amp; \\text{caso contr\u00e1rio}.   \\end{cases} \\] <p>Para verificar se \\(X\\) segundos s\u00e3o suficientes, note que cada m\u00e1quina \\(i\\) produz \\(\\lfloor X / a_i\\rfloor\\) produtos em \\(X\\) segundos (onde \\(a_i\\) \u00e9 o tempo que a m\u00e1quina \\(i\\) leva para fabricar um \u00fanico produto). Logo, o total produzido por \\(n\\) m\u00e1quinas \u00e9</p> \\[   \\sum_{i=1}^n \\Big\\lfloor \\frac{X}{a_i}\\Big\\rfloor. \\]"},{"location":"start/binarysearch/#monotonicidade","title":"Monotonicidade","text":"<p>Para aplicar busca bin\u00e1ria, \u00e9 fundamental que \\(f(X,t)\\) seja mon\u00f3tona:</p> <ol> <li>Se \\(f(x,t)=\\mathtt{true}\\), ent\u00e3o \\(f(y,t)=\\mathtt{true}\\) para todo \\(y \\ge x\\).  </li> <li>Se \\(f(x,t)=\\mathtt{false}\\), ent\u00e3o \\(f(y,t)=\\mathtt{false}\\) para todo \\(y \\le x\\).</li> </ol> <p>Isso garante que existe um ponto de corte \\(X'\\) tal que</p> \\[   f(X,t)=   \\begin{cases}   \\mathtt{false}, &amp; X &lt; X',\\\\   \\mathtt{true},  &amp; X \\ge X',   \\end{cases} \\] <p>e podemos encontr\u00e1\u2011lo eficientemente por busca bin\u00e1ria.</p>"},{"location":"start/binarysearch/#exemplo","title":"Exemplo","text":"<p>Caso de teste: <pre><code>3 7\n3 2 5\n// 3 m\u00e1quinas, queremos produzir 7 produtos.\n// Tempos: a = [3, 2, 5]\n</code></pre></p> <p>Ao atribuir valores de \\(1\\) a \\(10\\) \u00e0 fun\u00e7\u00e3o \\(f(X, t)\\), observamos o seguinte comportamento:</p> <p><pre><code>f(1, 7) = false\nf(2, 7) = false\nf(3, 7) = false\nf(4, 7) = false\nf(5, 7) = false\nf(6, 7) = false\nf(7, 7) = false\nf(8, 7) = true\nf(9, 7) = true\nf(10, 7) = true\n</code></pre> O ponto de corte \u00e9 \\(X' = 8\\).</p> <p>O interessante \u00e9 que podemos determinar o valor \u00f3timo a partir de uma estimativa inicial, usando busca bin\u00e1ria.</p>"},{"location":"start/binarysearch/#algoritmo-por-busca-binaria","title":"Algoritmo por busca bin\u00e1ria","text":"<p>Suponha que sabemos que a resposta est\u00e1 em \\([L, R]\\). Ent\u00e3o:</p> <ol> <li> <p>Calcule \\(    mid = \\left\\lfloor \\frac{L + R}{2} \\right\\rfloor.  \\)</p> </li> <li> <p>Avalie \\(f(mid, t)\\):  </p> <ul> <li> <p>Se \\(\\mathtt{true}\\), ent\u00e3o toda solu\u00e7\u00e3o \\(\\ge mid\\) tamb\u00e9m \u00e9 verdadeira \\(\\Rightarrow \\) atualize \\(R \\leftarrow mid. \\)</p> </li> <li> <p>Se \\(\\mathtt{false}\\), ent\u00e3o toda solu\u00e7\u00e3o \\(\\le mid\\) tamb\u00e9m \u00e9 falsa \\(\\Rightarrow \\) atualize  \\(L \\leftarrow mid + 1. \\)</p> </li> </ul> </li> <li> <p>Repita at\u00e9 \\(L = R\\). Esse valor \u00e9 o \\(X'\\) \u00f3timo.</p> </li> </ol>"},{"location":"start/binarysearch/#simulacao-da-busca-binaria-caso-dado-no-exemplo","title":"Simula\u00e7\u00e3o da busca bin\u00e1ria (caso dado no exemplo):","text":"<p>A seguir, a tabela que mostra cada itera\u00e7\u00e3o com \\(L\\), \\(R\\), \\(mid = \\big\\lfloor (L+R)/2\\big\\rfloor\\), o valor de \\(f(mid,7)\\) e a a\u00e7\u00e3o tomada:</p> Itera\u00e7\u00e3o \\(L\\) \\(R\\) \\(mid = \\lfloor (L+R)/2\\rfloor\\) \\(f(mid,7)\\) A\u00e7\u00e3o 1 0 20 10 true \\(R \\leftarrow 10\\) 2 0 10 5 false \\(L \\leftarrow 6\\) 3 6 10 8 true \\(R \\leftarrow 8\\) 4 6 8 7 false \\(L \\leftarrow 8\\) 5 8 8 8 true Fim: \\(X' = 8\\) <p>Para aplicar essa abordagem, podemos considerar um limite superior maior para o intervalo, por exemplo \\( [0,\\,10^{18}] \\), e implementar o algoritmo da seguinte forma:</p> factorymachines.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint n, t;\nvector&lt;int&gt; a;\n\n/**\n  * Verifica se m segundos \u00e9 suficiente para produzir\n  * pelo menos t produtos\n  * @param m quantidade de segundos\n  * @return true caso a quantidade m de segundos seja suficiente para \n  * produzir t produtos, false caso contr\u00e1rio.\n*/\nbool check(long long m) {\n  long long sum = 0, qtd = 0;\n  for (int i = 0; i &lt; n; i++) {\n    sum += (m / a[i]);\n    // evita overflow da vari\u00e1vel sum\n    if (sum &gt;= t) return true;\n  }\n  return sum &gt;= t;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int t = 1;\n  // cin &gt;&gt; t;\n  while(t--) {\n    cin &gt;&gt; n &gt;&gt; t;\n    a.resize(n);\n\n    for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i];\n    // Intervalo inicial de tempo [0, 1e18] \n    long long l = 0, r = (long long)1e18+10, ans;\n    while (l &lt;= r) {\n      long long m = (l + r) / 2;\n\n      if (check(m)) {\n        // se check retorna true, essa quantidade de tempo \u00e9 suficiente, \n        // salvamos ela na resposta e olhamos para o intervalo [l, m - 1]\n        // em busca de um valor menor\n        ans = m;\n        r = m - 1;\n      } else l = m + 1;\n        // se check retorna false, precisamos de uma quantidade maior de tempo, \n        // olhamos pro intervalo [m + 1, r]\n    }\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n  }\n  return 0;\n}\n</code></pre>"},{"location":"start/binarysearch/#implementacoes-do-c","title":"Implementa\u00e7\u00f5es do C++","text":"<p>O C++ possui algumas implementa\u00e7\u00f5es de busca bin\u00e1ria que s\u00e3o uteis em muitos problemas: </p>"},{"location":"start/binarysearch/#lower_bound","title":"lower_bound","text":"<p>Dado um vetor ordenado, retorna um ponteiro para primeira posi\u00e7\u00e3o maior ou igual a um valor \\(X \\) procurado.</p> <p>Complexidade: \\( \\mathcal{O}(\\log_2(N))\\)</p> <p>Sintaxe: <pre><code>lower_bound(first, last, val)\n</code></pre> Parametros:</p> <ul> <li>first: Ponteiro pro primeiro elemento do range</li> <li>last: Ponteiro pro \u00faltimo elemento do range</li> <li>val: Valor a ser comparado.</li> </ul>"},{"location":"start/binarysearch/#exemplo_1","title":"Exemplo:","text":"lower_bound.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n  vector&lt;int&gt; a = {10, 20, 30, 30, 40, 45, 50};\n\n  // encontrando o lower bound de 35 no vetor\n  cout &lt;&lt; *lower_boud(a.begin(), a.end(), 35) &lt;&lt; '\\n';\n  // tamb\u00e9m conseguimos guardar a posi\u00e7\u00e3o \n  // do lower_bound da seguinte forma\n  int p = lower_bound(a.begin(), a.end(), 35) - a.begin();\n  cout &lt;&lt; p &lt;&lt; '\\n\\';\n}\n</code></pre>"},{"location":"start/binarysearch/#upper_bound","title":"upper_bound","text":"<p>Dado um vetor ordenado, retorna um ponteiro para primeira posi\u00e7\u00e3o estritamente maior a um valor \\(X \\) procurado.</p> <p>Complexidade: \\( \\mathcal{O}(\\log_2(N))\\)</p> <p>Sintaxe:</p> <pre><code>lower_bound(first, last, val)\n</code></pre> <p>Parametros:</p> <ul> <li>first: Ponteiro pro primeiro elemento do range</li> <li>last: Ponteiro pro \u00faltimo elemento do range</li> <li>val: Valor a ser comparado.</li> </ul>"},{"location":"start/binarysearch/#exemplo_2","title":"Exemplo:","text":"upper_bound.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n  vector&lt;int&gt; a = {10, 20, 30, 30, 40, 45, 50};\n\n  // encontrando o upper bound de 35 no vetor\n  cout &lt;&lt; *upper_boud(a.begin(), a.end(), 35) &lt;&lt; '\\n';\n  // tamb\u00e9m conseguimos guardar a posi\u00e7\u00e3o \n  // do upper_bound da seguinte forma\n  int p = upper_bound(a.begin(), a.end(), 35) - a.begin();\n  cout &lt;&lt; p &lt;&lt; '\\n\\';\n}\n</code></pre> <p>Para mais detalhes sobre a implementa\u00e7\u00e3o dessas fun\u00e7\u00f5es:</p> <ul> <li>lower_bound</li> <li>upper_bound</li> </ul>"},{"location":"start/bitmanipulation/","title":"Manipula\u00e7\u00e3o de Bits","text":""},{"location":"start/complexity/","title":"Complexidade de Algoritmos","text":""},{"location":"start/complexity/#aula-relacionada-recomendada","title":"Aula relacionada recomendada","text":"C\u0155editos: Canal Maratona UFMG."},{"location":"start/complexity/#motivacao","title":"Motiva\u00e7\u00e3o","text":"<p>Pense no seguinte problema</p> <p>Dado um array de \\(n\\) inteiros, sua tarefa \u00e9 encontrar a soma m\u00e1xima dos valores em um subarray cont\u00edguo e n\u00e3o vazio.</p> <p>CSES - Maximum Subarray Sum</p> <p>Nota</p> <p>Tente resolver o problema antes de continuar a leitura.</p> <p>Em competi\u00e7\u00f5es de programa\u00e7\u00e3o, a efici\u00eancia dos algoritmos \u00e9 crucial, uma vez que os programas tem que ser executados em um tempo limite. Embora seja geralmente mais simples conceber uma solu\u00e7\u00e3o que resolva o problema, o verdadeiro desafio reside em otimiz\u00e1-la. Uma solu\u00e7\u00e3o lenta resultar\u00e1 em pouca ou nenhuma pontua\u00e7\u00e3o.</p>"},{"location":"start/complexity/#analise-de-complexidade","title":"An\u00e1lise de Complexidade","text":"<p>Para analisar o tempo que um programa demora para executar, vamos determinar o n\u00famero de opera\u00e7\u00f5es que um algoritmo executa em rela\u00e7\u00e3o ao tamanho da entrada, \\(n\\). Para isso, utilizamos a  Nota\u00e7\u00e3o Big O, que descreve o pior caso da complexidade de tempo. O que fazemos \u00e9 estabeler um limite superior, um m\u00e1ximo, para o n\u00famero de opera\u00e7\u00f5es que um programa executa.</p> <p>Quando expressamos a complexidade de uma fun\u00e7\u00e3o como \\(\\mathcal{O}(f(n))\\), geralmente omitimos fatores constantes e termos de ordem inferior de \\(f(n)\\). Veremos alguns exemplos pr\u00e1ticos de como isso funciona a seguir. Explicaremos o que queremos dizer com constantes e termos de ordem inferior com mais detalhes depois.</p>"},{"location":"start/complexity/#exemplos","title":"Exemplos:","text":""},{"location":"start/complexity/#operacoes-constantes","title":"Opera\u00e7\u00f5es constantes","text":"<p>O c\u00f3digo a seguir \u00e9 \\(\\mathcal{O}(1)\\), pois executa um n\u00famero constante de opera\u00e7\u00f5es.</p> <p><pre><code>int a;\ncin &gt;&gt; a;\nint b = 45;\nint c = a + b;\ncout &lt;&lt; c &lt;&lt; '\\n';\n</code></pre> Podemos assumir que opera\u00e7\u00f5es de entrada (input) e sa\u00edda (output) tamb\u00e9m s\u00e3o \\(\\mathcal{O}(1)\\).</p>"},{"location":"start/complexity/#loops","title":"Loops","text":"<p>A complexidade de um loop \u00e9 o n\u00famero de itera\u00e7\u00f5es do loop, o c\u00f3digo a seguir, por exemplo, tem complexidade \\(\\mathcal{O}(n)\\).</p> <pre><code>// O(n)\nfor (int i = 1; i &lt;= n; i++) {\n  // opera\u00e7\u00f5es constantes\n}\n</code></pre> <p>Como ignoramos constantes e fatores de ordem menor, o c\u00f3digo abaixo tamb\u00e9m \u00e9 \\(\\mathcal{O}(n)\\).</p> <p><pre><code>// O(n)\nfor (int i = 1; i &lt;= 3*n + 4356; i++) {\n  // opera\u00e7\u00f5es constantes\n}\n</code></pre> Para determinar a complexidade de loops aninhados, podemos multiplicar a complexidade de cada loop, o loop a seguir tem complexidade \\(\\mathcal{O}(n \\cdot m)\\).</p> <p><pre><code>// O(n*m)\nfor (int i = 1; i &lt;= n; i++) { // O(n)\n  for (int j = 1; j &lt;= m; j++) { // O(m)\n    // opera\u00e7\u00f5es constantes\n  }\n}\n</code></pre> O c\u00f3digo a seguir tem complexidade \\(\\mathcal{O}(n^2)\\). <pre><code>// O(n*n)\nfor (int i = 1; i &lt;= n; i++) { // O(n)\n  for (int j = 1; j &lt;= n; j++) { // O(n)\n    // opera\u00e7\u00f5es constantes\n  }\n}\n</code></pre></p> <p>Observa\u00e7\u00e3o</p> <p>Um programa com \\(k\\) loops aninhados vai ter complexidade \\(\\mathcal{O}(n^k)\\).</p> <p>Se um algoritmo possui m\u00faltiplos blocos de c\u00f3digo, consideramos a complexidade como a pior complexidade entre todos os blocos para a nota\u00e7\u00e3o Big O. No c\u00f3digo a seguir, temos um trecho que executa \\(n^2\\) itera\u00e7\u00f5es e outro que executa \\(n\\), para um \\(n\\) muito grande a contribui\u00e7\u00e3o de \\(n^2\\) ser\u00e1 muito maior que a contribui\u00e7\u00e3o de \\(n\\) para o n\u00famero total de itera\u00e7\u00f5es do programa (\\(n\\) tem ordem inferior a \\(n^2\\)). Assim, descartamos a contribui\u00e7\u00e3o de \\(n\\) para o c\u00e1lculo da complexidade, o c\u00f3digo a seguir tem complexidade \\(\\mathcal{O}(n^2)\\).</p> <pre><code>// O(n^2)\nfor (int i = 1; i &lt;= n; i++) {// O(n)\n  for (int j = 1; j &lt;= n; j++) { // O(n)\n    // opera\u00e7\u00f5es constantes\n  }\n}\n\n// O(n)\nfor (int i = 1; i &lt;= n; i++) {\n  // opera\u00e7\u00f5es constantes\n}\n</code></pre> <p>Analogia</p> <p>Imagine um tobo\u00e1gua com uma fila enorme, o tempo que demoramos na fila \u00e9 muito maior que o tempo que demoramos para desc\u00ea-lo. Assim, podemos considerar que o tempo para usar o tobo\u00e1gua \u00e9 o tempo que demoramos na fila, ignorando o tempo de descida. Isso \u00e9 a mesma coisa que fazemos na nota\u00e7\u00e3o Big O.</p> <p>No exemplo a seguir, a complexidade \u00e9 \\(\\mathcal{O}(n^2 + m)\\). Diferente do exemplo anterior o segundo loop depende de outro fator da entrada \\(m\\), esse fator n\u00e3o tem nenhuma rela\u00e7\u00e3o com \\(n\\), assim n\u00e3o podemos descart\u00e1-lo como no outro c\u00f3digo. Pois, possivelmente, a influ\u00eancia de \\(m\\) pode ser maior que a influ\u00eancia de \\(n^2\\) e vice-versa.</p> <pre><code>// O(n^2)\nfor (int i = 1; i &lt;= n; i++) {\n  for (int j = 1; j &lt;= n; j++) {\n    // opera\u00e7\u00f5es constantes\n  }\n}\n\n// O(m)\nfor (int i = 1; i &lt;= m; i++) {\n  // opera\u00e7\u00f5es constantes\n}\n</code></pre> <p>Para terminar a se\u00e7\u00e3o de loops, vamos estimar a complexidade do seguinte c\u00f3digo.  <pre><code>for (int i = 1; i &lt;= n; i++) {\n  for (int j = 1; j &lt;= i; j++) { \n    // opera\u00e7\u00f5es constantes\n  }\n}\n</code></pre> Nesse exemplo, a quantidade de itera\u00e7\u00f5es do loop interno vai depender do valor de \\(i\\), assim:</p> Loop externo Loop interno \\(i = 1\\) 1 itera\u00e7\u00e3o. \\(i = 2\\) 2 itera\u00e7\u00f5es. \\(i = 3\\) 3 itera\u00e7\u00f5es. \\(\\dots\\) \\(\\dots\\) \\(i = n\\) \\(n\\) itera\u00e7\u00f5es. <p>Assim vamos ter \\(1 + 2 + 3 + \\dots + n\\) itera\u00e7\u00f5es, ou seja, a soma de uma progress\u00e3o aritm\u00e9tica, ent\u00e3o teremos \\(\\dfrac{n*(1+n)}{2} = \\dfrac{n^2 + n}{2} = \\dfrac{1}{2}n^2 + \\dfrac{1}{2}n\\) itera\u00e7\u00f5es. Podemos ignorar as constantes, \\(n^2 + n\\), al\u00e9m disso temos que \\(n\\) tem menos influ\u00eancia (menor ordem) que \\(n^2\\), ent\u00e3o podemos ignor\u00e1-lo na nota\u00e7\u00e3o Big O. Desse modo, a complexidade \u00e9 \\(\\mathcal{O}(n^2)\\).</p>"},{"location":"start/complexity/#recursao","title":"Recurs\u00e3o","text":"<p>A complexidade de uma fun\u00e7\u00e3o recursiva \u00e9 determinada pelo n\u00famero de vezes que a fun\u00e7\u00e3o \u00e9 chamada multiplicado pela complexidade de cada chamada.</p> <p>Considere a seguinte fun\u00e7\u00e3o: <pre><code>void f(int val, int limite) {\n  if (val == limite) return;\n  f(val + 1, limite);\n}\n\nint main() {\n  int n;\n  cin &gt;&gt; n;\n  f(1, n);\n}\n</code></pre> A chamada <code>f(1, n)</code> resulta em \\(n\\) chamadas da fun\u00e7\u00e3o, e cada uma delas tem complexidade \\(\\mathcal{O}(1)\\). Sendo assim, a complexidade total \u00e9 \\(\\mathcal{O}(n)\\).</p> <p>Agora, vejamos a pr\u00f3xima fun\u00e7\u00e3o: fibonacci.cpp<pre><code>int fib(int n) {\n  if (n == 0) return 0;\n  if (n == 1) return 1;\n  return fib(n - 1) + fib(n - 2);  \n}\n\nint main() {\n  int n;\n  cin &gt;&gt; n;\n  fib(n);\n}\n</code></pre> Nesse caso, cada chamada da fun\u00e7\u00e3o <code>fib(n)</code> gera duas novas chamadas recursivas: <code>fib(n - 1)</code> e <code>fib(n - 2)</code>, exceto quando atinge os casos base, que s\u00e3o retornados diretamente sem gerar novas chamadas.</p> <p>A \u00e1rvore abaixo representa visualmente essa estrutura de chamadas para <code>fib(5)</code></p> <p>Observe que:</p> <ul> <li> <p>A \u00e1rvore cresce para a esquerda e para a direita a cada chamada, como uma \u00e1rvore bin\u00e1ria.</p> </li> <li> <p>Muitos valores s\u00e3o recalculados diversas vezes. Por exemplo, <code>fib(2)</code> \u00e9 chamado 3 vezes, <code>fib(1)</code> aparece 5 vezes.</p> </li> </ul> <p>Analisando a \u00e1rvore de cima para baixo, podemos estimar o total de chamadas considerando a quantidade de n\u00f3s (bolinhas) para cada n\u00edvel. O primeiro n\u00edvel tem \\(1\\) n\u00f3, no pr\u00f3ximo teremos o dobro (\\(2\\) n\u00f3s), depois teremos o dobro do dobro (\\(4\\) n\u00f3s) e os pr\u00f3ximos n\u00edveis tamb\u00e9m ter\u00e3o (uma estimativa pr\u00f3xima) o dobro de n\u00f3s do n\u00edvel anterior.</p> \\[ 1 + 2 + 4 + \\dots + 2^{n - 1} = 2^n-1 = \\mathcal{O}(2^n). \\] <p>A soma acima \u00e9 a soma de uma progress\u00e3o geom\u00e9trica e o desenvolvimento da f\u00f3rmula de sua soma resultar\u00e1 em \\(2^n-1\\).</p> <p>Ou seja, a complexidade de tempo da vers\u00e3o recursiva de Fibonacci \u00e9 exponencial.</p>"},{"location":"start/complexity/#complexidades-comuns","title":"Complexidades Comuns","text":"<ul> <li>F\u00f3rmulas matem\u00e1ticas que apenas calculam uma resposta:   \\(\\mathcal{O}(1)\\)</li> <li>Busca bin\u00e1ria: \\(\\mathcal{O}(\\log_2 (n))\\)</li> <li>Opera\u00e7\u00f5es em <code>Set</code>/<code>Map</code> ou <code>Priority Queue</code>: \\(\\mathcal{O}(\\log_2 (n))\\) por opera\u00e7\u00e3o</li> <li>Ordena\u00e7\u00e3o (Sorting): Geralmente implementado em \\(\\mathcal{O}(n \\log_2 (n))\\) nas fun\u00e7\u00f5es de ordena\u00e7\u00e3o padr\u00e3o das linguagens. Em C++, a complexidade \u00e9 essa.</li> <li>Iterar por todos os subconjuntos de um conjunto de tamanho \\(n\\): \\(\\mathcal{O}(2^n)\\)</li> <li>Iterar por todas as permuta\u00e7\u00f5es de tamanho \\(n\\): \\(\\mathcal{O}(n!)\\)</li> </ul>"},{"location":"start/complexity/#fator-constante","title":"Fator constante","text":"<p>Fator constante vai se referir a ideia de que diferentes c\u00f3digos com uma mesma complexidade Big O podem ter tempos de execu\u00e7\u00e3o distintos entre si. Um exemplo \u00e9 um c\u00f3digo que tem um loop e dentro do loop temos 10 <code>if</code>'s e outro c\u00f3digo com o mesmo loop, mas com um s\u00f3 <code>if</code>. Os dois c\u00f3digos tem mesma complexidade, por\u00e9m o primeiro c\u00f3digo vai ser mais lento (a diferen\u00e7a n\u00e3o vai ser grande, mas ela vai existir).</p> <p>Esse fator constante pode muitas vezes ser ignorado, pois ele n\u00e3o costuma ser relevante e ignor\u00e1-los nos ajudam a calcular a complexidade de um c\u00f3digo. Mas \u00e9 bom ter em mente que as constantes pode tornar o seu c\u00f3digo mais lento e que as vezes \u00e9 necess\u00e1rio otimizar o seu c\u00f3digo a fim de diminuir esses fatores constantes. Um exemplo \u00e9 tentar diminuir o n\u00famero de opera\u00e7\u00f5es que voc\u00ea faz, ou fazer opera\u00e7\u00f5es mais r\u00e1pidas (a opera\u00e7\u00e3o de multiplica\u00e7\u00e3o \u00e9 mais custosa para a CPU que a soma por exemplo).</p>"},{"location":"start/complexity/#complexidade-e-tempo-de-execucao","title":"Complexidade e tempo de execu\u00e7\u00e3o","text":"<p>Uma estimativa conservadora para o n\u00famero de opera\u00e7\u00f5es que um computador consegue realizar por segundo \u00e9 de \\(10^8\\), mas normalmente podemos considerar \\(4 \\cdot 10^8\\). A seguir uma tabela que dado um \\(n\\), mostra poss\u00edveis complexidades para um algoritmo.</p> \\(n\\) Complexidades poss\u00edveis \\(n \\leq 10\\) \\(\\mathcal{O}(n!), \\mathcal{O}(n^7), \\mathcal{O}(n^6)\\) \\(n \\leq 20\\) \\(\\mathcal{O}(2^nn), \\mathcal{O}(n^5)\\) \\(n \\leq 80\\) \\(\\mathcal{O}(n^4)\\) \\(n \\leq 400\\) \\(\\mathcal{O}(n^3)\\) \\(n \\leq 7500\\) \\(\\mathcal{O}(n^2)\\) \\(n \\leq 7 \\cdot 10^4\\) \\(\\mathcal{O}(n \\sqrt n)\\) \\(n \\leq 5 \\cdot 10^5\\) \\(\\mathcal{O}(n \\log n)\\) \\(n \\leq 5 \\cdot 10^6\\) \\(\\mathcal{O}(n)\\) \\(n \\leq 10^{18}\\) \\(\\mathcal{O}(\\log^2 n), \\mathcal{O}(\\log n), \\mathcal{O}(1)\\)"},{"location":"start/complexity/#solucao-do-problema-motivador-maximum-subarray-sum","title":"Solu\u00e7\u00e3o do problema motivador (Maximum Subarray Sum)","text":""},{"location":"start/complexity/#1a-solucao","title":"1\u00aa Solu\u00e7\u00e3o","text":"<p>Uma maneira direta de resolver o problema \u00e9 iterar sobre todos os subarrays poss\u00edveis, calcular a soma de cada um e registrar a maior soma encontrada.</p> <p>O c\u00f3digo a seguir implementa essa abordagem: <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n  int n;\n  cin &gt;&gt; n;\n  vector&lt;int&gt; a(n);\n  for (int i = 0; i &lt; n; i++) {\n    cin &gt;&gt; a[i];\n  }\n  long long ans = 0;\n  for (int l = 0; l &lt; n; l++) {\n    for (int r = 0; r &lt; n; r++) {\n      long long sum = 0;\n      for (int k = l; k &lt;= r; k++) {\n        sum += a[k];\n      }\n      ans = max(ans, sum);\n    }\n  }\n  cout &lt;&lt; ans &lt;&lt; '\\n';\n}\n</code></pre></p> <p>A complexidade dessa solu\u00e7\u00e3o \u00e9 \\(\\mathcal{O}(n^3)\\). Como \\(n\\) pode ser da ordem de \\(2 \\cdot 10^5\\), essa abordagem se torna invi\u00e1vel para a maioria dos casos.</p>"},{"location":"start/complexity/#2a-solucao","title":"2\u00aa Solu\u00e7\u00e3o","text":"<p>Para otimizar a complexidade, podemos usar o seguinte racioc\u00ednio: vamos nos concentrar em encontrar o subarray de maior soma que termina na posi\u00e7\u00e3o \\(k\\). Existem duas possibilidades para esse subarray:</p> <ol> <li> <p>Ele cont\u00e9m apenas o elemento na posi\u00e7\u00e3o \\(k\\).</p> </li> <li> <p>Ele \u00e9 formado pelo subarray de maior soma que termina na posi\u00e7\u00e3o \\(k\u22121\\), seguido pelo elemento na posi\u00e7\u00e3o \\(k\\).</p> </li> </ol> <p>Considerando que estamos buscando a soma m\u00e1xima global, o subarray que termina na posi\u00e7\u00e3o \\(k\u22121\\) tamb\u00e9m deve ter a maior soma poss\u00edvel para que a soma total seja m\u00e1xima. Com essa ideia, podemos resolver o problema eficientemente, calculando a soma m\u00e1xima do subarray que termina em cada posi\u00e7\u00e3o, da esquerda para a direita.</p> <p>O c\u00f3digo a seguir implementa essa abordagem:</p> <p><pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n  int n;\n  cin &gt;&gt; n;\n  vector&lt;int&gt; a(n);\n  for (int i = 0; i &lt; n; i++) {\n    cin &gt;&gt; a[i];\n  }\n  long long ans = 0, sum = 0;\n  for (int k = 0; k &lt; n; k++) {\n    sum = max(a[k], sum + a[k]);\n    ans = max(ans, sum);\n  }\n  cout &lt;&lt; ans &lt;&lt; '\\n';\n}\n</code></pre> Este algoritmo possui apenas um loop que itera sobre a entrada, resultando em uma complexidade final de \\(\\mathcal{O}(n)\\). Essa abordagem \u00e9 conhecida como Algoritmo de Kadane.</p>"},{"location":"start/cpp/","title":"C++","text":"<p>Este conte\u00fado tem o intuito de apresentar uma introdu\u00e7\u00e3o \u00e0 linguagem C++, a principal linguagem utilizada em programa\u00e7\u00e3o competitiva.</p>"},{"location":"start/cpp/#por-que-c","title":"Por que C++?","text":"<p>A linguagem C++ \u00e9 amplamente utilizada em programa\u00e7\u00e3o competitiva devido \u00e0 sua alta performance. Ela permite escrever c\u00f3digos r\u00e1pidos e otimizados, o que \u00e9 crucial em competi\u00e7\u00f5es, onde o tempo de execu\u00e7\u00e3o \u00e9 um fator decisivo. Al\u00e9m disso, o C++ oferece uma vasta biblioteca padr\u00e3o (STL), que inclui estruturas de dados e algoritmos eficientes, facilitando a implementa\u00e7\u00e3o de solu\u00e7\u00f5es complexas de maneira \u00e1gil. Sua sintaxe \u00e9 relativamente simples, portanto, \u00e9 uma \u00f3tima escolha para resolver problemas.</p>"},{"location":"start/cpp/#aprendendo-a-linguagem","title":"Aprendendo a linguagem","text":"<p>Se voc\u00ea \u00e9 iniciante em programa\u00e7\u00e3o, realizar um curso sobre a linguagem pode acelerar bastante seu aprendizado. Abaixo, voc\u00ea encontrar\u00e1 conte\u00fados em v\u00eddeo e texto para apoiar seu desenvolvimento. Se voc\u00ea j\u00e1 tem experi\u00eancia com programa\u00e7\u00e3o e conhece linguagens como C, Python, Java, entre outras, recomendamos fortemente que siga o tutorial em texto, que funciona de forma mais \u00e1gil, similar a uma documenta\u00e7\u00e3o. Caso nunca tenha tido contato com programa\u00e7\u00e3o, a escolha do formato fica a seu crit\u00e9rio.</p> <p>Conte\u00fado em Texto</p> <p>O conte\u00fado em texto ser\u00e1 mais conciso e abordar\u00e1 apenas os t\u00f3picos mais importantes. Por isso, ele n\u00e3o ser\u00e1 t\u00e3o detalhado quanto o conte\u00fado em v\u00eddeo.</p>"},{"location":"start/cpp/#conteudo-em-video-recomendado","title":"Conte\u00fado em v\u00eddeo recomendado","text":"O conte\u00fado que come\u00e7a a partir de ponteiros n\u00e3o \u00e9 obrigat\u00f3rio, mas \u00e9 \u00fatil. <p>Pro Tip</p> <p>Conhecimento sobre ponteiros, structs e classes \u00e9 \u00fatil, mas n\u00e3o \u00e9 obrigat\u00f3rio.</p>"},{"location":"start/cpp/#conteudo-em-texto-recomendado","title":"Conte\u00fado em texto recomendado","text":"<p>Para o conte\u00fado em texto, utilizaremos como refer\u00eancia o site W3Schools, que oferece um tutorial completo de C++. No entanto, os t\u00f3picos que ser\u00e3o mais importantes ser\u00e3o os descritos a seguir.</p> <p>W3Schools C++ Tutorial: https://www.w3schools.com/cpp/default.asp</p> <ul> <li><code>C++ Tutorial</code>, com exce\u00e7\u00e3o das se\u00e7\u00f5es <code>C++ Enums</code>, <code>C++ References</code> e <code>C++ Pointers</code>.</li> <li><code>C++ Functions</code>, com exce\u00e7\u00e3o da se\u00e7\u00e3o <code>C++ Lambda</code>.</li> <li><code>C++ How To</code>, sem exce\u00e7\u00f5es.</li> </ul> <p>As se\u00e7\u00f5es n\u00e3o citadas n\u00e3o s\u00e3o t\u00e3o relevantes.</p> <p>Para mais informa\u00e7\u00f5es: </p> <ul> <li> <p>C++ reference: https://en.cppreference.com/w/</p> </li> <li> <p>cplusplus.com: https://cplusplus.com/</p> </li> </ul>"},{"location":"start/cpp/#lista-de-exercicios","title":"Lista de Exerc\u00edcios","text":"<ul> <li>AtCoder - Doors in the Center</li> <li>AtCoder - Thermometer</li> <li>AtCoder - Triple Four</li> <li>CSES - Weird Algorithm</li> <li>CSES - Missing Number</li> <li>CSES - Repetitions</li> <li>Codeforces - Watermelon</li> <li>Codeforces - Way Too Long Words</li> <li>Codeforces - Team</li> <li>Codeforces - Bit++</li> </ul>"},{"location":"start/fenwick/","title":"Fenwick Tree","text":""},{"location":"start/geometry/","title":"Geometria","text":""},{"location":"start/greedy/","title":"Algoritmo Guloso","text":""},{"location":"start/greedy/#aula-relacionada-recomendada","title":"Aula relacionada recomendada:","text":"C\u0155editos: Canal Maratona UFMG."},{"location":"start/greedy/#motivacao","title":"Motiva\u00e7\u00e3o","text":"<p>Pense no seguinte problema</p> <p>Um restaurante recebeu \\(n\\) pedidos de reserva. Cada pedido reserva o restaurante por um per\u00edodo cont\u00ednuo de tempo, sendo o \\(i\\)-\u00e9simo pedido caracterizado por dois valores: o instante de in\u00edcio \\(l_i\\) e o instante de t\u00e9rmino \\(r_i\\) (com \\(l_i \\leq r_i\\)).</p> <p>A administra\u00e7\u00e3o do restaurante pode aceitar ou recusar os pedidos. Qual \u00e9 o n\u00famero m\u00e1ximo de pedidos que podem ser aceitos?</p> <p>Importante: nenhum par de pedidos aceitos pode se sobrepor, ou seja, eles n\u00e3o podem compartilhar nem mesmo um instante de tempo. Se um pedido termina exatamente no mesmo momento em que outro come\u00e7a, ambos n\u00e3o podem ser aceitos simultaneamente.</p> <p>Codeforces - Restaurant</p>"},{"location":"start/numbertheory/","title":"Teoria dos N\u00fameros","text":"<p>Teoria dos n\u00fameros \u00e9 um ramo da matem\u00e1tica que estuda n\u00fameros inteiros. Nessa se\u00e7\u00e3o, assumiremos que todos os n\u00fameros s\u00e3o inteiros.</p>"},{"location":"start/numbertheory/#divisores","title":"Divisores","text":"<p>Um n\u00famero \\(a\\) \u00e9 chamado de divisor ou fator de um n\u00famero \\(b\\) se \\(a\\) divide \\(b\\). Escrevemos \\(a \\mid b\\) e temos a seguinte propriedade:</p> \\[ b = a \\cdot k, k \\in \\mathbb{Z} \\] <p>Por exemplo, os divisores de \\(24\\) s\u00e3o \\(1, 2, 3, 4, 6, 8, 12\\) e \\(24\\).</p> \\[ 24 = 1 \\cdot 24 = 2 \\cdot 12 = 3 \\cdot 8 = \\cdots = 24 \\cdot 1 \\]"},{"location":"start/numbertheory/#primos","title":"Primos","text":"<p>Um n\u00famero \\(n &gt; 1\\) \u00e9 primo se seus \u00fanicos divisores positivos s\u00e3o \\(1\\) e \\(n\\). Por exemplo, \\(7, 19\\) e \\(41\\) s\u00e3o primos, mas 35 n\u00e3o \u00e9 primo pois \\(5 \\cdot 7 = 35\\). Para todo n\u00famero \\(n &gt; 1\\) existe uma \u00fanica fatora\u00e7\u00e3o em primos:</p> \\[ n = p_1^{\\alpha_1} p_2^{\\alpha_2} \\cdots p_k^{\\alpha_k}, \\] <p>em que \\(p_1, p_2, ..., p_k\\) s\u00e3o primos distintos e \\(\\alpha_1, \\alpha_2, \\cdots, \\alpha_k\\) s\u00e3o inteiros positivos. Por exemplo, a fatora\u00e7\u00e3o do n\u00famero 84 \u00e9:</p> \\[     84 = 2^{2} \\cdot 3^{1} \\cdot 7^{1} \\]"},{"location":"start/numbertheory/#numero-de-divisores","title":"N\u00famero de divisores","text":"<p>O n\u00famero de divisores de um n\u00famero \\(n\\) \u00e9:</p> \\[ \\tau(n) = \\prod_{i=1}^{k} (\\alpha_i + 1), \\] <p>porque para todo primo \\(p_i,\\) existem \\(\\alpha_i + 1\\) formas de escolher quantas vezes ele aparece no divisor, de \\(p_i^0\\) at\u00e9 \\(p_i^{\\alpha_i}\\). Por exemplo, o n\u00famero de divisores de 84 \u00e9:</p> \\[ \\tau(84) = 3 \\cdot 2 \\cdot 2 = 12. \\]"},{"location":"start/numbertheory/#soma-dos-divisores","title":"Soma dos divisores","text":"<p>A soma dos fatores de \\(n\\) \u00e9:</p> \\[ \\sigma(n) = \\prod_{i=1}^{k} (1 + p_i + \\cdots + p_i^{\\alpha_i}) = \\prod_{i=1}^{k} \\left(\\frac{p_i^{\\alpha_i+1} - 1} {p_i - 1} \\right), \\] <p>pois podemos escolher qualquer pot\u00eancia dos primos presentes na fatora\u00e7\u00e3o de \\(n\\), de \\(p_i^{0} = 1\\) at\u00e9 \\(p_i^{\\alpha_i}\\). A simplifica\u00e7\u00e3o pode ser feita pela soma de progress\u00e3o geom\u00e9trica com raz\u00e3o \\(p_i\\):</p> \\[ \\begin{align} S &amp;= 1 + p_i + \\cdots + p_i^{\\alpha_i -1} +  p_i^{\\alpha_i} \\\\ S \\cdot p_i &amp;= p_i + p_i^{2} + \\cdots + p_i^{\\alpha_i}+ p_i^{\\alpha_i + 1} \\\\ S \\cdot p_i - S &amp;= p_i^{\\alpha_i+1} - p_i^{\\alpha_i} + p_i^{\\alpha_i} - \\cdots + \\cdots - p_i + p_i - 1 \\\\ S \\cdot (p_i - 1) &amp;= p_i^{\\alpha_i+1} - 1 \\\\ S &amp;= \\frac{p_i^{\\alpha_i+1} - 1}{p_i - 1} \\end{align} \\] <p>Por exemplo, a soma dos fatores de 84 \u00e9:</p> \\[ \\sigma(84) = \\frac{2^{3}-1}{2-1} \\cdot \\frac{3^{2}-1}{3-1} \\cdot \\frac{7^{2}-1}{7-1} =  7 \\cdot 4 \\cdot 8 = 224 \\]"},{"location":"start/numbertheory/#produto-dos-divisores","title":"Produto dos divisores","text":"<p>O produto dos divisores de \\(n\\) \u00e9:</p> \\[ \\mu(n) = n^{\\tau(n)/2}, \\] <p>porque podemos formar \\(\\tau(n)/2\\) pares de divisores, cada um com produto igual \u00e0 \\(n\\). Por exemplo, os doze fatores de \\(84\\) produzem seis pares:</p> \\[ \\begin{align} 1 \\cdot 84 \\\\ 2 \\cdot 42 \\\\ 3 \\cdot 28 \\\\ 4 \\cdot 21 \\\\ 6 \\cdot 14 \\\\ 7 \\cdot 12  \\end{align} \\] <p>e o produto dos fatores \u00e9 \\(\\mu(84) = 84^{6} = 351298031616\\).</p>"},{"location":"start/numbertheory/#densidade-de-primos","title":"Densidade de primos","text":"<p>A densidade de n\u00fameros primos \\(\\pi(n)\\) representa a quantidade de primos entre \\(1\\) e \\(n\\). Temos a aproxima\u00e7\u00e3o:</p> \\[     \\pi(n) \\approx \\frac{n}{\\ln(n)} \\] <p>Por exemplo \\(\\pi(10) = 4,\\) pois temos \\(4\\) primos entre \\(1\\) e \\(10:\\) \\(2, 3, 5, 7\\).  </p>"},{"location":"start/numbertheory/#algoritmos-basicos","title":"Algoritmos b\u00e1sicos","text":"<p>Se um n\u00famero \\(n\\) n\u00e3o \u00e9 primo, ele pode ser representado como um produto \\(a \\cdot b,\\) em que \\(a \\leq \\sqrt{n}\\) ou \\(b \\leq \\sqrt{n}\\), portanto existe um fator entre \\(2\\) e \\(\\lfloor\\sqrt{n}\\rfloor\\). Assim, podemos testar se um n\u00famero \u00e9 primo e achar sua fatora\u00e7\u00e3o em \\(O(\\sqrt{n})\\).</p>"},{"location":"start/numbertheory/#identificar-se-um-numero-e-primo","title":"Identificar se um n\u00famero \u00e9 primo","text":"<p>A fun\u00e7\u00e3o \\(is \\_ prime\\) abaixo checa se o n\u00famero \\(n\\) \u00e9 primo. Sabemos que o \u00fanico n\u00famero par primo \u00e9 \\(2\\), portanto podemos checar a paridade de \\(n\\) e tentar dividir \\(n\\) apenas pelos n\u00fameros impares entre \\(3\\) e \\(\\lfloor \\sqrt{n} \\rfloor\\). is_prime.cpp<pre><code>bool is_prime(int n) {\n    if (n &lt; 2) return false;\n    if(n%2==0) return n==2;\n\n    for (int x = 3; x*x &lt;= n; x+=2) {\n        if (n%x == 0) return false;\n    }\n\n    return true;\n}\n</code></pre></p>"},{"location":"start/numbertheory/#fatorar-um-numero","title":"Fatorar um n\u00famero","text":"<p>A fun\u00e7\u00e3o \\(factor\\) abaixo retorna um vetor que cont\u00e9m a fatora\u00e7\u00e3o em primos do n\u00famero \\(n\\). A fun\u00e7\u00e3o divide \\(n\\) pelos seus divisores primos e os adiciona no vector. O processo encerra quando \\(n\\) n\u00e3o tem mais fatores entre \\(2\\) e \\(\\lfloor \\sqrt{n} \\rfloor\\). Ao final do processo, se \\(n &gt; 1\\), ele \u00e9 primo e \u00e9 o \u00faltimo divisor.</p> <p>factor.cpp<pre><code>vector&lt;int&gt; factors(int n) {\n    vector&lt;int&gt; f;\n\n    for (int x = 2; x*x &lt;= n; x++) {\n        while (n%x == 0) {\n            f.push_back(x);\n            n /= x;\n        }\n    }\n    if (n &gt; 1) f.push_back(n);\n\n    return f;\n}\n</code></pre> Note que cada fator primo aparece no vetor a quantidade de vezes que ele divide o n\u00famero. Por exemplo, \\(24 = 2^3  \\cdot 3\\), portanto o resultado da fun\u00e7\u00e3o ser\u00e1 \\([2, 2, 2, 3]\\).</p>"},{"location":"start/numbertheory/#crivo-de-eratostenes","title":"Crivo de Erat\u00f3stenes","text":"<p>O crivo de Erat\u00f3stenes \u00e9 um algoritmo que constr\u00f3i um vetor no qual podemos usar de maneira eficiente para determinar se um determinado n\u00famero entre \\(0\\) e \\(n\\) \u00e9 primo. O algoritmo constr\u00f3i um vetor \\(prime\\) cujas posi\u00e7\u00f5es \\(0, 1, 2, 3, \\cdots, n\\) s\u00e3o usadas. O valor \\(prime[k] = 1\\) significa que \\(k\\) \u00e9 primo, e o valor \\(prime[k] = 0\\) significa que \\(k\\) n\u00e3o \u00e9 primo.</p> <p>O algoritmo itera sobre os n\u00fameros \\(2, \\cdots, n\\) um por um. Sempre que um novo primo \\(x\\) \u00e9 encontrado, o algoritmo guarda que os m\u00faltiplos de \\(x\\) \\((2x, 3x, 4x, \\cdots)\\) n\u00e3o s\u00e3o primos, pois s\u00e3o divis\u00edveis por x.</p> crivo.cpp<pre><code>vector&lt;int&gt; crivo(int N) {\n    vector&lt;int&gt;prime(N+1, 1);\n    prime[0] = prime[1] = 0;\n\n    for (int x = 2; x &lt;= N; x++) {\n        if(prime[x]){\n            for(int y = x+x; y &lt;= N; y+=x){\n                prime[y] = 0;\n            }\n        }\n    }\n    return prime;\n}\n</code></pre> <p>O loop interior do algoritmo \u00e9 executado \\(n/x\\) vezes para cada valor de \\(x\\). Portanto, um upper bound para a complexidade de tempo \u00e9 a s\u00e9rie harm\u00f4nica </p> \\[     \\sum_{x=2}^{n} \\frac {n}{x} = \\frac {n}{2} + \\frac {n}{3} + \\cdots + \\frac {n}{n} = \\mathcal{O}(n \\log{n}) \\] <p>Na realidade, o algoritmo \u00e9 mais eficiente, pois o loop interior vai ser executado apenas se o n\u00famero \\(x\\) \u00e9 primo, cuja frequ\u00eancia \u00e9 aproximadamente \\(\\frac{n}{\\ln(n)}\\). Portanto, a complexidade de tempo do algoritmo \u00e9 \\(\\mathcal{O}(n \\log \\log n)\\), sendo muito pr\u00f3xima de \\(\\mathcal{O}(n)\\).</p> <p>Podemos alterar o algoritmo para obter a fatora\u00e7\u00e3o de cada n\u00famero entre \\(2\\) e \\(n\\), criando um novo vetor \\(d\\) de vectors, em que \\(d[k]\\) guarda a fatora\u00e7\u00e3o em primos do n\u00famero \\(k\\).</p> crivo_div.cpp<pre><code>vector&lt;vector&lt;int&gt;&gt; crivo(int N) {\n    vector&lt;int&gt;prime(N, 1);\n    prime[0] = prime[1] = 0;\n    vector&lt;vector&lt;int&gt;&gt;d(N);\n\n    for (int x = 2; x &lt; N; x++) {\n        if(prime[x]){\n            d[x].push_back(x);\n            for(int y = x+x; y &lt; N; y+=x){\n                prime[y] = 0;\n\n                int t = y;\n                while(t%x==0){\n                    d[y].push_back(x);\n                    t/=x;\n                }\n            }\n        }\n    }\n    return d;\n}\n</code></pre>"},{"location":"start/numbertheory/#maximo-divisor-comum-mdc-ou-gcd","title":"M\u00e1ximo Divisor Comum (MDC ou GCD)","text":"<p>O m\u00e1ximo divisor comum de dois n\u00fameros \\(a\\) e \\(b\\), \\(\\gcd(a,b)\\), \u00e9 o maior n\u00famero que divide tanto \\(a\\) quanto \\(b\\). Por exemplo, \\(\\gcd(24,36) = 12\\).</p>"},{"location":"start/numbertheory/#algoritmo-de-euclides","title":"Algoritmo de Euclides","text":"<p>O algoritmo de euclides \u00e9 uma maneira eficiente de calcular o \\(\\gcd\\) de dois n\u00fameros. Ele \u00e9 baseado na seguinte f\u00f3rmula:</p> \\[ \\gcd(a,b) =  \\begin{cases} a, &amp; \\text{se } b = 0 \\\\ \\gcd(b, a \\bmod b), &amp; \\text{se } b \\neq 0  \\end{cases} \\] <p>O algoritmo de Euclides funciona em tempo \\(\\mathcal{O}(\\log n)\\), em que \\(n = \\min(a,b)\\).</p> <p>O pior caso acontece quando \\(a\\) e \\(b\\) s\u00e3o n\u00fameros consecutivos de Fibonacci. Por exemplo,</p> \\[ \\gcd(13,8) = \\gcd(8,5) = \\gcd(5,3) = \\gcd(3,2) = \\gcd(2,1) = \\gcd(1,0) = 1 \\] gcd.cpp<pre><code>int gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b, a%b);\n}\n</code></pre>"},{"location":"start/numbertheory/#minimo-multiplo-comum-mmc-ou-lcm","title":"M\u00ednimo m\u00faltiplo comum (MMC ou LCM)","text":"<p>O m\u00ednimo m\u00faltiplo comum de dois n\u00fameros \\(a\\) e \\(b\\), \\(lcm(a,b)\\), \u00e9 o menor n\u00famero que \u00e9 divis\u00edvel por \\(a\\) e por \\(b\\). Por exemplo, \\(lcm(24,36) = 72.\\)</p> <p>O \\(\\gcd\\) e o \\(lcm\\) possuem a seguinte propriedade:</p> \\[     lcm(a,b) = \\frac{ab}{\\gcd(a,b)} \\]"},{"location":"start/numbertheory/#funcao-totiente-de-euler","title":"Fun\u00e7\u00e3o totiente de Euler","text":"<p>N\u00fameros \\(a\\) e \\(b\\) s\u00e3o coprimos se \\(\\gcd(a,b) = 1\\). A fun\u00e7\u00e3o totiente de Euler \\(\\varphi(n)\\) calcula a quantidade de n\u00fameros coprimos com \\(n\\) entre \\(1\\) e \\(n\\). Por exemplo, \\(\\varphi(12) = 4\\), porque \\(1, 5, 7\\) e \\(11\\) s\u00e3o coprimos com \\(12\\).</p> <p>O valor de \\(\\varphi(n)\\) pode ser calculado pela fatora\u00e7\u00e3o em primos de \\(n\\) usando a formula:</p> \\[ \\varphi(n) = \\prod_{i=1}^{k} (p_i^{\\alpha_i - 1} \\cdot (p_i - 1)) \\] <p>Por exemplo, \\(\\varphi(12) = (2^1 \\cdot (2-1)) \\cdot (3^0 \\cdot (3-1)) = 4\\). </p> <p>Note que \\(\\varphi(n) = n-1\\) se \\(n\\) \u00e9 primo.</p>"},{"location":"start/numbertheory/#aritmetica-modular","title":"Aritm\u00e9tica modular","text":"<p>Na aritm\u00e9tica modular, o conjunto de n\u00fameros \u00e9 limitado para apenas \\(0, 1, 2, \\cdots, m-1\\), em que \\(m\\) \u00e9 uma constante.</p> <p>Cada n\u00famero \\(x\\) \u00e9 representado pelo n\u00famero \\(r\\) tal que </p> \\[ 0 \\le r &lt; m \\\\ \\] \\[ x = m \\cdot k + r, k \\in \\mathbb{Z} \\] <p>Por exemplo, \\(75 \\bmod 17 = 7\\).</p> <p>Pode-se calcular o m\u00f3dulo antes de algumas opera\u00e7\u00f5es para evitar n\u00fameros muito grandes. Algumas propriedades s\u00e3o:</p> \\[ \\begin{align} (x + y) \\bmod m &amp;= (x \\bmod m + y \\bmod m) \\bmod m \\\\ (x - y) \\bmod m &amp;= (x \\bmod m - y \\bmod m) \\bmod m \\\\ (x \\cdot y) \\bmod m &amp;= (x \\bmod m \\cdot y \\bmod m) \\bmod m \\\\ x^n \\bmod m &amp;= (x \\bmod m)^n \\bmod m \\end{align} \\]"},{"location":"start/numbertheory/#exponenciacao-rapida","title":"Exponencia\u00e7\u00e3o R\u00e1pida","text":"<p>Existe um jeito de calcular o valor de \\(x^n \\bmod m\\) em \\(\\mathcal{O}(\\log n)\\) utilizando a seguinte recurs\u00e3o:</p> \\[ x^n =  \\begin{cases} 1 &amp;,\\text{se $n = 0$} \\\\ x^{n/2} \\cdot x^{n/2} &amp;, \\text{se $n$ for par} \\\\ x^{n-1} \\cdot x &amp;, \\text{se $n$ for impar}  \\end{cases} \\] <p>\u00c9 importante que no caso de \\(n\\) ser par, o valor de \\(x^{n/2}\\) \u00e9 calculado apenas uma vez. Isso garante a complexidade \\(\\mathcal{O}(\\log n)\\), porque \\(n\\) \u00e9 sempre dividido por dois quando \u00e9 par. </p> fastexp.cpp<pre><code>int fastexp(int x, int n, int m){\n    if(n==0) return 1;\n    long long p = fastexp(x, n/2, m);\n    p = (p * p) % m;\n    if(n%2 == 1) p = (p * x) % m;\n    return p;\n}\n</code></pre>"},{"location":"start/numbertheory/#pequeno-teorema-de-fermat-e-teorema-de-euler","title":"Pequeno Teorema de Fermat e Teorema de Euler","text":"<p>Para um \\(m\\) primo e coprimo com \\(x\\), o pequeno teorema de Fermat afirma que</p> \\[ x^{m-1} \\bmod m  = 1 \\] <p>Pode-se expandir para </p> \\[ x^k \\bmod m = x^{k \\bmod (m-1)} \\bmod m \\] <p>De forma geral, o teorema de Euler para \\(x\\) e \\(m\\) coprimos afirma que</p> \\[ x^{\\varphi (m)} \\bmod m = 1 \\] <p>O teorema de Fermat \u00e9 equivalente ao teorema de Euler, pois \\(\\varphi (m) = m-1\\) para \\(m\\) primo.</p>"},{"location":"start/numbertheory/#inverso-modular","title":"Inverso modular","text":"<p>O inverso de \\(x \\bmod m\\) \u00e9 um n\u00famero \\(x^{-1}\\) tal que</p> \\[ x \\cdot x^{-1} \\bmod m = 1 \\] <p>Usando inversos modulares, \u00e9 poss\u00edvel dividir n\u00fameros m\u00f3dulo \\(m\\), porque divis\u00e3o por \\(x\\) corresponde \u00e0 multiplica\u00e7\u00e3o por \\(x^{-1}\\).</p> <p>No entanto, o inverso modular nem sempre existe. Por exemplo, se \\(x = 2\\) e \\(m = 4\\), a equa\u00e7\u00e3o \\(x \\cdot x^{-1} \\bmod m = 1\\) n\u00e3o tem solu\u00e7\u00e3o, porque todos os m\u00faltiplos de 2 ser\u00e3o pares e o resto nunca poder\u00e1 ser \\(1\\) quando \\(m = 4\\). Temos que \\(x^{-1} \\bmod m\\) pode ser calculado apenas quando \\(x\\) e \\(m\\) s\u00e3o coprimos.</p> <p>Pelo teorema de Euler,</p> \\[ x^{\\varphi(m)} \\bmod m = x \\cdot x^{\\varphi(m) - 1} \\bmod m = 1 \\] <p>Portanto, por defini\u00e7\u00e3o, os n\u00fameros \\(x^{-1}\\) e \\(x^{\\varphi(m)-1}\\) s\u00e3o equivalentes m\u00f3dulo \\(m\\).</p> \\[ x^{-1} = x^{\\varphi(m)-1} \\bmod m \\] <p>Se \\(m\\) \u00e9 primo, obtemos</p> \\[ x^{-1} = x^{m-2} \\bmod m \\] <p>Essa f\u00f3rmula permite calcular inversos modulares de uma forma eficiente utilizando o algoritmo da exponencia\u00e7\u00e3o r\u00e1pida. </p> mod_inverse.cpp<pre><code>int inv(int x, int m){\n    return fexp(x, m-2, m);\n}\n</code></pre> <p>Por exemplo, \\(6^{-1} \\bmod 17 = 6^{17 - 2} \\bmod 17 = 3\\). Note que \\(6 \\cdot 3 \\bmod 17 = 1\\).</p>"},{"location":"start/numbertheory/#problemas-recomendados","title":"Problemas recomendados","text":"<ul> <li>CSES - Counting Divisors</li> <li>CSES - Next Prime</li> <li>Atcoder - Div Game</li> <li>CSES - Divisor Analysis</li> <li>CSES - Common Divisors</li> <li>Atcoder - LCM Sequence</li> <li>CSES - Exponentiation</li> <li>CSES - Exponentiation II</li> <li>CSES - Prime Multiples</li> <li>CSES - Counting Coprime Pairs</li> <li>CSES - Sum of Divisors</li> </ul>"},{"location":"start/practicing/","title":"Praticando","text":""},{"location":"start/prefixsum/","title":"Soma de prefixo","text":""},{"location":"start/prefixsum/#motivacao","title":"Motiva\u00e7\u00e3o","text":"<p>Pense no seguinte problema</p> <p>Dado um array de inteiros com \\( n \\) elementos, e \\( q \\) consultas do tipo \\( [i, j] \\), retorne a soma dos elementos do intervalo \\( [i, j] \\) do array.</p> <p>CSES - Static Range Sum Queries</p> <p>Note</p> <p>Tente resolver o problema antes de continuar a leitura.</p> <p>Uma abordagem consistiria em calcular a soma de cada intervalo individualmente. Para cada consulta \\( [i, j] \\), somar\u00edamos diretamente os elementos \\( a_i + a_{i+1} + \\ldots + a_j \\). A complexidade dessa abordagem \u00e9 \\( \\mathcal{O}(n) \\) opera\u00e7\u00f5es por consulta, resultando em uma complexidade total de \\( \\mathcal{O}(nq) \\) para \\( q \\) consultas. Considerando que tanto \\( n \\) quanto \\( q \\) podem ser da ordem de \\( 10^5 \\), essa abordagem \u00e9 computacionalmente lenta.</p>"},{"location":"start/prefixsum/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Na abordagem acima possivelmente iremos realizar v\u00e1rios c\u00e1lculos repetidamente, a ideia aqui \u00e9 pr\u00e9-processar o array \\( a \\) e armazenar as somas parciais em um novo array. Seja \\( prefix \\) esse array, iremos definir \\( prefix[i] \\) como a soma dos primeiros \\( i \\) elementos do array \\( a \\).</p> <p>Assim, podemos calcular a soma de qualquer intervalo \\( [i, j] \\) em tempo constante \\( \\mathcal{O}(1) \\), coletando o valor da soma dos \\( j \\) primeiros elementos e subtraindo/removendo todos os elementos anteriores a \\( i \\), ou seja, os \\( i - 1 \\) primeiros elementos. Mostraremos que a complexidade de pr\u00e9-processamento \u00e9 \\( \\mathcal{O}(n) \\), resultando em uma complexidade total de \\( \\mathcal{O}(n + q) \\) para \\( q \\) consultas.</p>"},{"location":"start/prefixsum/#definicao","title":"Defini\u00e7\u00e3o","text":"<p>Seja \\( a \\) um array de inteiros, o array \\( prefix \\) \u00e9 definido como:</p> \\[ prefix[i] = a_1 + a_2 + \\ldots + a_{i-1} + a_i \\] <p>Ou seja:</p> \\[ prefix[i] = prefix[i - 1] + a_i \\] <p>Dessa forma, podemos calcular a soma de qualquer intervalo \\( [i, j] \\) como:</p> \\[ range(i, j) = prefix[j] - prefix[i - 1] \\] <p>Pois:</p> \\[ range(i, j) = prefix[j] - prefix[i - 1] \\] \\[ = (a_1 + a_2 + \\ldots + a_{j-1} + a_j) - (a_1 + a_2 + \\ldots + a_{i-1}) \\] \\[ = ((a_1 + a_2 + \\ldots + a_{i-1}) + (a_i + a_{i+1} + \\ldots + a_{j-1} + a_j)) - (a_1 + a_2 + \\ldots + a_{i-1}) \\] \\[ = (a_i + a_{i+1} + \\ldots + a_{j-1} + a_j) + (a_1 + a_2 + \\ldots + a_{i-1}) - (a_1 + a_2 + \\ldots + a_{i-1}) \\] \\[ = a_i + a_{i+1} + \\ldots + a_{j-1} + a_j \\]"},{"location":"start/prefixsum/#codigo","title":"C\u00f3digo","text":"<p>Esse c\u00f3digo \u00e9 um exemplo de como implementar a t\u00e9cnica de prefixo para a soma. Assim, podemos calcular o range de \\( i \\) at\u00e9 \\( j \\) como:</p> psum.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin &gt;&gt; n &gt;&gt; q;\n    vector&lt;int&gt; prefix(n + 1);\n\n    // Para evitar o caso de ind\u00edce negativo em\n    // prefix[i-1], indexaremos o array a partir de 1\n    prefix[0] = 0;\n\n    // O(n)\n    for (int i = 1; i &lt;= n; i++) {\n        int x;\n        cin &gt;&gt; x;\n        prefix[i] = prefix[i - 1] + x;\n    }\n\n    // O(q)\n    while (q--) {\n        int l, r;\n        cin &gt;&gt; l &gt;&gt; r;\n        cout &lt;&lt; prefix[r] - prefix[l - 1] &lt;&lt; '\\n';\n    }\n}\n</code></pre>"},{"location":"start/prefixsum/#outras-estruturas-algebricas","title":"Outras estruturas alg\u00e9bricas","text":"<p>Imagine que para resolver certo problema, voc\u00ea precise realizar os c\u00e1lculo de um range de um array utilizando uma opera\u00e7\u00e3o que n\u00e3o seja a de soma, como o produto ou bitwise XOR. Nessa se\u00e7\u00e3o, vamos ver como podemos generalizar o conceito de soma de prefixo para outras opera\u00e7\u00f5es e verificar se podemos ou n\u00e3o utilizar a t\u00e9cnica.</p> <p>Para isso, a rigor matem\u00e1tico, \u00e9 necess\u00e1rio que dado um conjunto \\( G \\) e uma opera\u00e7\u00e3o \\( \\star \\), \\( (G, \\star) \\) seja um grupo.</p>"},{"location":"start/prefixsum/#propriedades-de-um-grupo","title":"Propriedades de um grupo","text":"<p>\\( (G, \\star) \\) \u00e9 um grupo se, e somente se, satisfaz as seguintes propriedades:</p>"},{"location":"start/prefixsum/#fechamento","title":"Fechamento","text":"<p>Operar quaisquer dois elementos de \\( G \\) com \\( \\star \\) deve resultar em um elemento de \\( G \\)</p> \\[ \\forall x, y \\in G, x \\star y \\in G \\]"},{"location":"start/prefixsum/#associatividade","title":"Associatividade","text":"<p>A opera\u00e7\u00e3o \\( \\star \\) deve ser associativa, ou seja, a ordem de aplica\u00e7\u00e3o da opera\u00e7\u00e3o entre quaisquer tr\u00eas elementos n\u00e3o importa</p> \\[ \\forall x, y, z \\in G, (x \\star y) \\star z = x \\star (y \\star z) \\]"},{"location":"start/prefixsum/#elemento-neutro","title":"Elemento neutro","text":"<p>Deve existir um elemento \\( e \\) em \\( G \\), tal que, operar qualquer elemento \\( x \\) em \\( G \\) com \\( e \\) resulta em \\( x \\)</p> \\[ \\forall x \\in G, \\exists e \\in G : x \\star e = e \\star x = x \\]"},{"location":"start/prefixsum/#inverso","title":"Inverso","text":"<p>Deve existir um elemento \\( y \\) em \\( G \\) para cada elemento \\( x \\) em \\( G \\), tal que, operar \\( x \\) com \\( y \\) resulta no elemento neutro \\( e \\)</p> \\[ \\forall x \\in G, \\exists y \\in G : x \\star y = y \\star x = e \\] <p>Dessa forma, poderemos utilizar todo o conhecimento adquirido acima. Pois, seja:</p> \\[ prefix[i] = a_1 \\star a_2 \\star \\ldots \\star a_{i-1} \\star a_i \\] <p>Observe que \\( prefix[i] \\) pertence a \\( G \\) pela propriedade de fechamento. Dessa forma:</p> \\[ prefix[i] = prefix[i-1] \\star a_i \\] <p>Como \\( prefix[i] \\) pertence a \\( G \\), logo \\( prefix[i] \\) possui um elemento inverso, seja \\( prefix[i]^{-1} \\) esse elemento. Assim, podemos definir a opera\u00e7\u00e3o de range como:</p> \\[ range(i, j) = prefix[i-1]^{-1} \\star prefix[j] \\] <p>Pois:</p> \\[ range(i, j) = (a_1 \\star a_2 \\star \\ldots \\star a_{i-1})^{-1} \\star (a_1 \\star a_2 \\star \\ldots \\star a_{j-1} \\star a_j) \\] \\[ = (a_1 \\star a_2 \\star \\ldots \\star a_{i-1})^{-1} \\star (a_1 \\star a_2 \\star \\ldots \\star a_{i-1}) \\star (a_{i} \\star a_{i+1} \\star a_{i+2} \\star \\ldots \\star a_j) \\] \\[ = ((a_1 \\star a_2 \\star \\ldots \\star a_{i-1})^{-1} \\star (a_1 \\star a_2 \\star \\ldots \\star a_{i-1})) \\star (a_{i} \\star a_{i+1} \\star a_{i+2} \\star \\ldots \\star a_j) \\] \\[ = e \\star (a_{i} \\star a_{i+1} \\star a_{i+2} \\star \\ldots \\star a_j) \\] \\[ = a_{i} \\star a_{i+1} \\star a_{i+2} \\star \\ldots \\star a_j \\] <p>Note</p> <ul> <li>Linha 2 e 3: Associatividade</li> <li>Linha 4: Inverso</li> <li>Linha 5: Elemento neutro</li> </ul>"},{"location":"start/prefixsum/#exemplo-da-operacao-de-range","title":"Exemplo da opera\u00e7\u00e3o de range","text":"<p>Tome o array \\( \\{ a_1, a_2, a_3, a_4, a_5 \\} \\), tal que, \\( a_1, a_2, a_3, a_4, a_5 \\in G \\) e \\( (G, \\star) \\) \u00e9 um grupo e deseja calcular o \\( range(3, 5) \\):</p> \\[ range(3, 5) = prefix[2]^{-1} \\star prefix[5] \\] \\[ = (a_1 \\star a_2)^{-1} \\star (a_1 \\star a_2 \\star a_3 \\star a_4 \\star a_5) \\] \\[ = (a_1 \\star a_2)^{-1} \\star (a_1 \\star a_2) \\star (a_3 \\star a_4 \\star a_5) \\] \\[ = ((a_1 \\star a_2)^{-1} \\star (a_1 \\star a_2)) \\star (a_3 \\star a_4 \\star a_5) \\] \\[ = e \\star (a_3 \\star a_4 \\star a_5) \\] \\[ = a_3 \\star a_4 \\star a_5 \\]"},{"location":"start/prefixsum/#exemplo-de-grupos","title":"Exemplo de grupos","text":""},{"location":"start/prefixsum/#soma-nos-reais","title":"Soma nos reais","text":"<p>\\( ( \\mathbb{R}, + ) \\)</p> <ul> <li>Elemento neutro: \\( 0 \\)</li> <li>Inverso: Fun\u00e7\u00e3o de subtra\u00e7\u00e3o</li> </ul>"},{"location":"start/prefixsum/#multiplicacao-nos-inteiros","title":"Multiplica\u00e7\u00e3o nos inteiros","text":"<p>\\( ( \\mathbb{Z}, * ) \\)</p> <ul> <li>Elemento neutro: \\( 1 \\)</li> <li>Inverso: Fun\u00e7\u00e3o de divis\u00e3o</li> </ul>"},{"location":"start/prefixsum/#bitwise-xor-nos-inteiros","title":"Bitwise XOR nos inteiros","text":"<p>\\( ( \\mathbb{Z}, \\oplus ) \\)</p> <ul> <li>Elemento neutro: \\( 0 \\)</li> <li>Inverso: Fun\u00e7\u00e3o de bitwise XOR</li> </ul>"},{"location":"start/prefixsum/#codigo-geral","title":"C\u00f3digo geral","text":"<p>Esse c\u00f3digo \u00e9 um exemplo de como implementar a t\u00e9cnica de prefixo para o produto. Para isso, utilizamos o inverso da multiplica\u00e7\u00e3o, que \u00e9 a divis\u00e3o. Assim, podemos calcular o range de \\( i \\) at\u00e9 \\( j \\) como:</p> solve.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nvector&lt;double&gt; prefix;\n\ndouble neutro = 1.0;\n// elemento neutro para soma seria:\n// int neutro = 0;\n\ndouble inverso(double x) {\n    return 1.0 / x;\n    // Inverso da soma seria:\n    // return -x;\n}\n\ndouble operacao(double x, double y) {\n    return x * y;\n    // Opera\u00e7\u00e3o de soma seria:\n    // return x + y;\n}\n\ndouble range(int i, int j) {\n    return operacao(inverso(prefix[i - 1]), prefix[j]);\n}\n\nint main() {\n    int n, q;\n    cin &gt;&gt; n &gt;&gt; q;\n    prefix.resize(n + 1);\n    prefix[0] = neutro;\n\n    // O(n)\n    for (int i = 1; i &lt;= n; i++) {\n        double x;\n        cin &gt;&gt; x;\n        prefix[i] = operacao(prefix[i - 1], x);\n    }\n\n    // O(q)\n    while (q--) {\n        int l, r;\n        cin &gt;&gt; l &gt;&gt; r;\n        cout &lt;&lt; range(l, r) &lt;&lt; endl;\n    }\n}\n</code></pre>"},{"location":"start/prefixsum/#lista-de-exercicios","title":"Lista de exerc\u00edcios","text":"<ul> <li>CSES - Static Range Sum Queries</li> <li>CSES - Range Xor Queries</li> <li>Codeforces - Odd Queries</li> <li>Codeforces - Black and White Stripe</li> <li>Atcoder - GCD on Blackboard</li> <li>Codeforces - Sereja and Suffixes</li> <li>Codeforces - Good Subarrays</li> <li>Codeforces - Prefix Sum Addicts</li> <li>CSES - Subarray Sums II</li> <li>CSES - Subarray Divisibility</li> </ul>"},{"location":"start/recursion/","title":"Recurs\u00e3o","text":""},{"location":"start/recursion/#aula-relacionada-recomendada","title":"Aula relacionada recomendada","text":""},{"location":"start/recursion/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Recurs\u00e3o \u00e9 definir algo em termos de si pr\u00f3prio. Um dos exemplos mais cl\u00e1ssicos para ilustrar esse conceito \u00e9 a sequ\u00eancia de Fibonacci. Ela \u00e9 uma sequ\u00eancia de n\u00fameros inteiros de tal forma que os primeiros elementos s\u00e3o \\(0\\) e \\(1\\) e os pr\u00f3ximos elementos s\u00e3o definidos como a soma dos dois anteriores.</p> <p>Em linguagem mat\u00e9matica, definimos o \\(n\\)-\u00e9simo termo de Fibonacci como:</p> \\[ F(n) =  \\begin{cases} 0, \\text{ se } n = 0 \\\\ 1, \\text{ se } n = 1 \\\\ F(n-1) + F(n-2) \\end{cases} \\] <p>No nosso contexto, vamos sempre estar trabalhando com fun\u00e7\u00f5es recursivas, e considerando a sequ\u00eancia de Fibonacci, podemos escrever uma fun\u00e7\u00e3o recursiva que retorna o \\(n\\)-\u00e9simo n\u00famero de Fibonacci. Em c\u00f3digo: fibonacci.cpp<pre><code>int fib(int n) {\n  if (n == 0) return 0;\n  if (n == 1) return 1;\n  return fib(n - 1) + fib(n - 2);  \n}\n</code></pre></p> <p>Observa\u00e7\u00e3o</p> <p>Cada chamada recursiva vai criar um novo \"ambiente\", as vari\u00e1veis e argumentos s\u00e3o diferentes para cada chamada da fun\u00e7\u00e3o recursiva. Assim quando uma fun\u00e7\u00e3o recursiva se chama, apesar dos nomes das vari\u00e1veis serem os mesmos, os valores em cada v\u00e1riavel s\u00e3o independentes entre si. Como se fossem v\u00e1rias caixas com o mesmo nome, mas com conte\u00fados distintos.</p> <p>Podemos perceber que a defini\u00e7\u00e3o matem\u00e1tica do termo de Fibonacci e a fun\u00e7\u00e3o que fizemos s\u00e3o muito similares. Primeiramente, definimos o que chamamos de casos bases, que s\u00e3o situa\u00e7\u00f5es em que n\u00e3o definimos a fun\u00e7\u00e3o em termos de si mesma, na sequ\u00eancia de Fibonacci, os casos bases seriam quando \\(n\\) \u00e9 igual a \\(0\\) ou \\(1\\). Depois, definimos as rela\u00e7\u00f5es de recorr\u00eancia, quando n\u00e3o estamos tratando os casos b\u00e1sicos. Nelas, a fun\u00e7\u00e3o recursiva \u00e9 definida em termo dela mesma, e como ela se relaciona consigo mesma \u00e9 o que chamaremos de rela\u00e7\u00e3o de recorr\u00eancia. Uma fun\u00e7\u00e3o pode ter mais de uma rela\u00e7\u00e3o de recorr\u00eancia. </p> <p>Usando a recurs\u00e3o, podemos resolver muitos problemas com bastante facilidade. A seguir, veremos exemplos de como utilizar a recursividade.</p> <p>Recomenda\u00e7\u00e3o</p> <p>Nos exemplos, execute os c\u00f3digos e tente simular o fluxo de execu\u00e7\u00e3o da fun\u00e7\u00e3o recursiva para diferentes valores. Para cada chamada da fun\u00e7\u00e3o, tente escrever os valores das vari\u00e1veis e argumentos para ajudar na compreens\u00e3o.</p>"},{"location":"start/recursion/#exemplos","title":"Exemplos:","text":""},{"location":"start/recursion/#contagem-regressiva","title":"Contagem regressiva","text":"<p>Vamos definir uma fun\u00e7\u00e3o que imprime os n\u00fameros de \\(N\\) at\u00e9 \\(1\\) de maneira decrescente (uma contagem regressiva) usando a recursividade. Primeiro analisamos os possiveis casos base. Neste exemplo, temos um caso base, quando \\(n = 1\\). Quando \\(n = 1\\), vamos imprimir o n\u00famero \\(1\\) e encerrar a contagem. Agora definimos as rela\u00e7\u00f5es de recorr\u00eancia, se \\(n &gt; 1\\), ent\u00e3o imprimimos o n\u00famero \\(n\\) na tela e continuamos a contagem a partir do n\u00famero \\(n-1\\). Ou seja:</p> \\[ ContagemRegressiva(n) =  \\begin{cases} \\text{imprimir } 1, \\text{ se } n =1 \\\\ \\text{imprimir } n \\text{ e chamar } ContagemRegressiva(n-1), \\text{ se } n &gt; 1 \\end{cases} \\] <p>Em c\u00f3digo: <pre><code>void ContagemRegressiva(int n){\n  if(n == 1){\n    cout &lt;&lt; 1 &lt;&lt; '\\n';\n    return;\n  }\n  cout &lt;&lt; n &lt;&lt; '\\n';\n  ContagemRegressiva(n-1);\n}\n</code></pre> Agora basta chamar a fun\u00e7\u00e3o <code>ContagemRegressiva(N)</code> que ela ir\u00e1 realizar a contagem regressiva de \\(N\\) at\u00e9 \\(1\\).</p> <p>Recomenda\u00e7\u00e3o</p> <p>Sempre tente escrever a fun\u00e7\u00e3o recursiva no papel, voc\u00ea n\u00e3o precisa definir ela de maneira completamente matem\u00e1tica, mas escrever no papel como a fun\u00e7\u00e3o recursiva funciona vai te ajudar a implement\u00e1-la.</p>"},{"location":"start/recursion/#contagem-progressiva","title":"Contagem progressiva","text":"<p>Agora vamos definir uma fun\u00e7\u00e3o que imprime os n\u00fameros de \\(1\\) at\u00e9 \\(N\\) de maneira crescente (uma contagem progressiva). Pensando no exemplo anterior, poder\u00edamos considerar o caso base \\(n = N\\) em que imprimos \\(n\\) e encerramos a contagem. A rela\u00e7\u00e3o de recorr\u00eancia seria quando \\(n &lt; N\\), nesse caso imprimimos \\(n\\) e continuamos a contagem a partir do n\u00famero \\(n+1\\). Ou seja:</p> \\[ ContagemProgressiva(n,N) =  \\begin{cases} \\text{imprimir } n, \\text{ se } n = N \\\\ \\text{imprimir } n \\text{ e chamar } ContagemProgressiva(n+1,N), \\text{ se } n &lt; N \\end{cases} \\] <p>Por\u00e9m, existe outra maneira de definir essa fun\u00e7\u00e3o de tal maneira que n\u00e3o precisamos desse segundo par\u00e2metro \\(N\\). Considerando:</p> \\[ ContagemProgressiva(n) =  \\begin{cases} \\text{imprimir } 1, \\text{ se } n = 1 \\\\ \\text{chamar } ContagemProgressiva(n-1) \\text{ e imprimir } n, \\text{ se } n &gt; 1 \\end{cases} \\] <p>Em c\u00f3digo: <pre><code>void ContagemProgressiva(int n){\n  if(n == 1){\n    cout &lt;&lt; 1 &lt;&lt; '\\n';\n    return;\n  }\n  ContagemProgressiva(n-1);\n  cout &lt;&lt; n &lt;&lt; '\\n';\n}\n</code></pre> Usando esse c\u00f3digo, conseguimos fazer uma contagem progressiva de \\(1\\) at\u00e9 \\(N\\) chamando <code>ContagemProgressiva(N)</code> sem precisar usar dois par\u00e2metros. Essa implementa\u00e7\u00e3o parece muito similar a da <code>ContagemRegressiva(n)</code>, com exce\u00e7\u00e3o de que a impress\u00e3o agora \u00e9 feita depois da chamada recursiva, esse detalhe que faz a diferen\u00e7a. Quando chamamos a fun\u00e7\u00e3o recursiva primeiro, vamos chamar a fun\u00e7\u00e3o recursivamente at\u00e9 alcan\u00e7armos o caso base \\(n = 1\\). Somento quando \\(n = 1\\), vamos imprimir o n\u00famero \\(1\\) e retornar das fun\u00e7\u00f5es mais internas e imprimir os pr\u00f3ximos n\u00fameros em ordem crescente.</p>"},{"location":"start/recursion/#subconjuntos","title":"Subconjuntos","text":"<p>Dado um conjunto \\(S\\) de n\u00fameros naturais, vamos criar um programa que imprime todos os subconjuntos de \\(S\\). Para fazer isso, inicialmente, vamos ter um conjunto \\(T\\) vazio que usaremos para construir todos os subconjuntos poss\u00edveis. Considere que \\(S\\) tem \\(N\\) elementos. Para cada elemento, podemos escolher inclu\u00ed-lo em \\(T\\) ou n\u00e3o. Cada escolha gera um novo subconjunto. Vamos pensar em uma defini\u00e7\u00e3o recursiva com essa ideia em mente, para cada elemento \\(x\\) em \\(S\\), temos duas op\u00e7\u00f5es: </p> <ul> <li>incluir \\(x\\) em \\(T\\) e gerar o conjunto \\(T \\cup \\{x\\}\\) ou </li> <li>n\u00e3o incluir \\(x\\) em \\(T\\) e manter o mesmo conjunto \\(T\\). </li> </ul> <p>Ap\u00f3s fazer a escolha para \\(x\\), podemos desconsiderar \\(x\\) em \\(S\\) e passar a considerar o conjunto \\(S - \\{x\\}\\). Com essa ideia, podemos implementar a fun\u00e7\u00e3o recursiva.</p> \\[ Subconjuntos(S,T) =  \\begin{cases} \\text{imprimir } T, \\text{ se } S = \\emptyset \\\\ Subconjuntos(S-x,T \\cup x) \\text{ e } Subconjuntos(S-x,T), \\text{ se } S \\neq \\emptyset \\text{ e considerando } x \\in S \\end{cases} \\] <p>Em c\u00f3digo: <pre><code>void Subconjuntos(vector&lt;int&gt; S, vector&lt;int&gt; T){\n  if(S.empty()){\n    Imprimir(T); // Fun\u00e7\u00e3o que imprime o subconjunto\n    return;\n  }\n  int x = S.back();\n  S.pop_back(); // Retiramos o elemento x de S\n\n  // Op\u00e7\u00e3o de incluir x em T\n  T.push_back(x);\n  Subconjuntos(S,T); // Subconjuntos(S-x,T + {x})\n\n  // Op\u00e7\u00e3o de n\u00e3o incluir x em T\n  T.pop_back(); // Desfazemos a opera\u00e7\u00e3o que fizemos anteriormente de incluir x em T\n  Subconjuntos(S,T); // Subconjuntos(S-x,T)\n}\n</code></pre> Mas existe um problema nessa implementa\u00e7\u00e3o que vamos evitar. Toda vez que chamamos a fun\u00e7\u00e3o recursivamente, passamos o <code>vector</code> como argumento, isso vai alocar espa\u00e7o na mem\u00f3ria a cada chamada e atrasar o nosso programa. Para evitar isso vamos considerar \\(S\\) e \\(T\\) <code>vector</code>'s globais e vamos utilizar \u00edndices para considerar os elementos de S e tamb\u00e9m o caso base. <pre><code>vector&lt;int&gt; S,T;\nvoid Subconjuntos(int pos){\n  // consideramos todos os elementos de S\n  if(pos == S.size()){\n    Imprimir(T); // Fun\u00e7\u00e3o que imprime o subconjunto\n    return;\n  }\n  int x = S[pos]; // estamos considerando o elemento na posi\u00e7ao \"pos\"\n\n  // Op\u00e7\u00e3o de incluir x em T\n  T.push_back(x);\n  Subconjuntos(pos+1); \n\n  // Op\u00e7\u00e3o de n\u00e3o incluir x em T\n  T.pop_back(); // Desfazemos a opera\u00e7\u00e3o que fizemos anteriormente de incluir x em T\n  Subconjuntos(pos+1);\n}\n</code></pre> Agora para imprimir os subconjuntos, basta chamar <code>Subconjuntos(0)</code>.</p> <p>Recomenda\u00e7\u00e3o</p> <p>Se voc\u00ea tem que alterar uma estrutura mais complicada em uma fun\u00e7\u00e3o <code>vector</code>, <code>set</code> ou <code>map</code> por exemplo. Tente colocar essas estruturas globalmente, assim voc\u00ea tem menos chance de sem querer passar essas estruturas como argumento e alocar mem\u00f3ria desnecessariamente.</p>"},{"location":"start/recursion/#lista-de-exercicios","title":"Lista de exerc\u00edcios","text":"<ul> <li>CSES - Creating Strings</li> <li>Atcoder - Enumerate Sequences</li> <li>OBI - Falta uma</li> <li>Atcoder - 1 2 1 3 1 2 1</li> <li> GYM Codeforces - Gift</li> <li> Codeforces - Gold Rush</li> <li>Atcoder - Skill Up</li> <li>Atcoder - Changing Jewels</li> <li>CSES - Apple Division</li> <li>CSES - Tower of Hanoi</li> </ul>"},{"location":"start/segtree/","title":"Segment Tree","text":""},{"location":"start/stl/","title":"C++ Standard Template Library (STL)","text":""},{"location":"start/stl/#aula-relacionada-recomendada","title":"Aula relacionada recomendada","text":"C\u0155editos: Canal Maratona UFMG."},{"location":"start/stl/#conhecendo-a-stl","title":"Conhecendo a STL","text":"<p>A Standard Template Library (STL) do C++ \u00e9 um conjunto de classes e fun\u00e7\u00f5es baseadas em templates que implementam estruturas de dados e algoritmos amplamente utilizados, como listas, pilhas, vetores, ordena\u00e7\u00e3o, busca, entre outros.</p> <p>Nesta se\u00e7\u00e3o, vamos conhecer as principais estruturas e algoritmos da STL que s\u00e3o usados na programa\u00e7\u00e3o competitiva.</p> <p>As estruturas de dados mais comuns s\u00e3o:</p> Estrutura Descri\u00e7\u00e3o <code>vector</code> Armazena elementos como um array, mas pode alterar seu tamanho dinamicamente. A adi\u00e7\u00e3o e remo\u00e7\u00e3o de elementos geralmente ocorrem no final, e os elementos podem ser acessados por \u00edndice. <code>set</code> Armazena elementos \u00fanicos de forma ordenada (crescente). Elementos n\u00e3o podem ser acessados por \u00edndice. <code>map</code> Armazena elementos em pares \"chave/valor\". Pode ser acessado atrav\u00e9s das chaves, e n\u00e3o pelo \u00edndice. <code>pair</code> Armazena dois valores como um \u00fanico elemento, onde cada valor pode ter um tipo diferente. O acesso aos valores \u00e9 feito por meio de <code>first</code> e <code>second</code>. <code>stack</code> Armazena elementos em uma ordem espec\u00edfica, chamada LIFO (Last In, First Out), onde os elementos podem ser adicionados e removidos apenas do topo (como uma pilha). N\u00e3o \u00e9 acess\u00edvel por \u00edndice. <code>queue</code> Armazena elementos em uma ordem espec\u00edfica, chamada FIFO (First In, First Out), onde os elementos s\u00e3o adicionados no final e removidos da frente (como uma fila). N\u00e3o \u00e9 acess\u00edvel por \u00edndice. <code>priority_queue</code> Armazena elementos em uma ordem espec\u00edfica, os elementos de maior prioridade aparecem primeiro (por padr\u00e3o, os elementos de maior valor), \u00e9 parecido com a queue, pois voc\u00ea s\u00f3 pode acessar os elementos da frente, mas aqui a ordem \u00e9 determinada n\u00e3o pela ordem de inser\u00e7\u00e3o. N\u00e3o \u00e9 acess\u00edvel por \u00edndice. <code>deque</code> Armazena elementos em uma fila de duas extremidades (deque), onde os elementos podem ser adicionados e removidos de ambos os lados. Os elementos podem ser acessados por \u00edndice. <p>Os algoritmos mais comuns s\u00e3o:</p> Algoritmo Descri\u00e7\u00e3o <code>sort</code> Ordena os elementos em uma estrutura de dados. <code>reverse</code> Inverte a ordem dos elementos em um determinado intervalo. <code>swap</code> Troca os valores de duas vari\u00e1veis."},{"location":"start/stl/#template-basico-para-a-pratica-desta-secao","title":"Template b\u00e1sico para a pr\u00e1tica desta se\u00e7\u00e3o","text":"<p>Para facilitar nossa pr\u00e1tica nessa se\u00e7\u00e3o utilizaremos esse template simples para praticar as estruturas:</p> template.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n\n  return 0;\n}\n</code></pre>"},{"location":"start/stl/#include-bitsstdch","title":"<code>#include &lt;bits/stdc++.h&gt;</code>","text":"<p>\u00c9 um arquivo de cabe\u00e7alho que j\u00e1 inclui todas as bibliotecas padr\u00e3o, ou seja, voc\u00ea n\u00e3o precisa dar <code>#include</code> manualmente para cada estrutura de dados ou algoritmo que for usar. Por exemplo, se precisar de <code>vector</code> e <code>set</code>, normalmente teria que incluir <code>#include &lt;vector&gt;</code> e <code>#include &lt;set&gt;</code> separadamente. Com <code>#include &lt;bits/stdc++.h&gt;</code>, tudo isso j\u00e1 vem junto, facilitando o uso e economizando tempo.</p>"},{"location":"start/stl/#using-namespace-std","title":"<code>using namespace std;</code>","text":"<p>O <code>using namespace std;</code> \u00e9 uma diretiva no C++ que permite que voc\u00ea use os elementos da biblioteca padr\u00e3o (std) sem precisar escrever <code>std::</code> antes de cada um deles. Isso facilita a escrita do c\u00f3digo, pois voc\u00ea n\u00e3o precisa digitar <code>std::</code> repetidamente para acessar coisas como <code>cout</code>, <code>cin</code>, <code>vector</code>, entre outros.</p> <p>Por exemplo, se voc\u00ea n\u00e3o usar o <code>using namespace std;</code>, seria necess\u00e1rio escrever <code>std::cout</code>, <code>std::cin</code>, <code>std::vector</code>, etc. Com o <code>using namespace std;</code>, basta escrever <code>cout</code>, <code>cin</code>, <code>vector</code>, e o compilador entender\u00e1 automaticamente que voc\u00ea est\u00e1 se referindo \u00e0 vers\u00e3o padr\u00e3o dessas fun\u00e7\u00f5es e estruturas.</p>"},{"location":"start/stl/#estruturas-de-dados","title":"Estruturas de Dados","text":"<p>Em cada um dos links abaixo, voc\u00ea encontra refer\u00eancias que ensinam a utilizar cada uma das estruturas.</p> <ul> <li><code>vector</code>: https://www.geeksforgeeks.org/vector-in-cpp-stl/</li> <li><code>set</code>: https://www.geeksforgeeks.org/set-in-cpp-stl/</li> <li><code>map</code>: https://www.geeksforgeeks.org/cpp/map-associative-containers-the-c-standard-template-library-stl/</li> <li><code>pair</code>: https://www.geeksforgeeks.org/pair-in-cpp-stl/</li> <li><code>stack</code>: https://www.geeksforgeeks.org/stack-in-cpp-stl/</li> <li><code>queue</code>: https://www.geeksforgeeks.org/queue-cpp-stl/</li> <li><code>priority_queue</code>: https://www.geeksforgeeks.org/cpp/priority-queue-in-cpp-stl/</li> <li><code>deque</code>:  https://www.geeksforgeeks.org/deque-cpp-stl/</li> </ul>"},{"location":"start/stl/#algoritmos","title":"Algoritmos","text":"<p>Em cada um dos links abaixo, voc\u00ea encontra refer\u00eancias que ensinam a utilizar cada um dos algoritmos.</p> <p>https://www.geeksforgeeks.org/swap-in-cpp/</p> <ul> <li><code>sort</code>: https://www.geeksforgeeks.org/sort-c-stl/</li> <li><code>reverse</code>: https://www.geeksforgeeks.org/stdreverse-in-c/</li> <li><code>swap</code>: https://www.geeksforgeeks.org/swap-in-cpp/</li> </ul> <p>Pro Tip</p> <p>Conhecer as estruturas e algoritmos b\u00e1sicos da STL v\u00e3o te ajudar bastante na sua jornada em programa\u00e7\u00e3o competitiva.</p>"},{"location":"start/stl/#lista-de-exercicios","title":"Lista de exerc\u00edcios","text":"<ul> <li>CSES - Distinct Numbers</li> <li>OBI - Copa do Mundo</li> <li>Neps Academy - Mini Dicion\u00e1rio</li> <li>OBI - Sinuca</li> <li>OBI - Frequ\u00eancia na aula</li> <li>OBI - Zero para Cancelar</li> <li>OBI - Times</li> <li>OBI - Bombom</li> <li>OBI - Express\u00f5es</li> <li>OBI - Quebra-cabe\u00e7a</li> </ul>"},{"location":"start/twopointers/","title":"Two Pointers","text":""},{"location":"start/dp/intro/","title":"Introdu\u00e7\u00e3o","text":""},{"location":"start/dp/knapsack/","title":"Knapsack DP","text":""},{"location":"start/dp/lcs/","title":"LCS","text":""},{"location":"start/dp/paths/","title":"Caminhos em Matrizes","text":""},{"location":"start/graphs-intro/introduction/","title":"Introdu\u00e7\u00e3o","text":"<p>Essa se\u00e7\u00e3o tem o intuito de apresentar uma introdu\u00e7\u00e3o \u00e0 Teoria dos Grafos.</p>"},{"location":"start/graphs-intro/introduction/#definicao","title":"Defini\u00e7\u00e3o","text":"<p>Um grafo \u00e9 representado por um par ordenado \\(G = (V, E)\\), em que \\(V\\) \u00e9 o conjunto de v\u00e9rtices e \\(E\\) \u00e9 o conjunto de arestas. Eles podem ser utilizados para representar rela\u00e7\u00f5es entre os v\u00e9rtices, atrav\u00e9s do uso das arestas. Por exemplo, os v\u00e9rtices podem ser vistos como cidades e as arestas como estradas, em que a aresta \\((U,V)\\) existe se h\u00e1 uma estrada entre as cidades \\(U\\) e \\(V\\).</p> <p>Os exemplos a seguir ser\u00e3o baseados no seguinte grafo:</p> \\[     V = \\{A, B, C, D\\} \\] \\[     E = \\{             (A, B), (A, C),             (B, C), (B, D),             (C, D)         \\} \\]"},{"location":"start/graphs-intro/introduction/#vizinhanca","title":"Vizinhan\u00e7a","text":"<p>Definimos a vizinhan\u00e7a \\(N\\) de um v\u00e9rtice \\(V\\) como o conjunto de v\u00e9rtices que est\u00e3o ligados diretamente a \\(V\\) atrav\u00e9s de uma aresta. Em grafos direcionados, se temos a aresta \\((U,V)\\), ent\u00e3o \\(V\\in N(U)\\) e \\(U\\notin N(V)\\).  </p> \\[ N(V) = \\{U | (V,U) \\in E\\} \\] \\[ \\begin{aligned}     &amp;N(A) = \\{B,C\\} \\\\     &amp;N(B) = \\{A,C,D\\} \\\\     &amp;N(C) = \\{A,B,D\\} \\\\     &amp;N(D) = \\{B,C\\}  \\end{aligned} \\]"},{"location":"start/graphs-intro/introduction/#grau","title":"Grau","text":"<p>O grau de um v\u00e9rtice \\(V\\) \u00e9 o n\u00famero de arestas que incidem em \\(V\\). Se existe uma aresta que liga um v\u00e9rtice nele mesmo (loops), ela conta duas vezes em seu grau.  Em grafos direcionados, temos dois tipos de grau: de entrada e saida, que representam, respectivamente, o n\u00famero de arestas que entram e saem no v\u00e9rtice.</p> \\[     Deg(V) = \\left|N(V) \\right| + loops \\] \\[ \\begin{aligned} &amp;Deg(A) = 2 \\\\ &amp;Deg(B) = 3 \\\\ &amp;Deg(C) = 3 \\\\ &amp;Deg(D) = 2  \\end{aligned} \\]"},{"location":"start/graphs-intro/introduction/#componente-conexa","title":"Componente Conexa","text":"<p>Uma componente conexa de um grafo \u00e9 um subgrafo em que todo par de v\u00e9rtices est\u00e1 conectado por um caminho e n\u00e3o h\u00e1 conex\u00e3o com v\u00e9rtices que n\u00e3o perten\u00e7am a tal subgrafo.</p> <p>O grafo acima possui duas componentes conexas:</p> \\[ \\begin{align}     C_1 &amp;= \\{A, B, C \\}  \\\\     C_2 &amp;= \\{E, F, G, H \\} \\end{align} \\]"},{"location":"start/graphs-intro/introduction/#tipos-de-grafo","title":"Tipos de Grafo","text":""},{"location":"start/graphs-intro/introduction/#arvore","title":"\u00c1rvore","text":"<p>Uma \u00e1rvore \u00e9 um tipo de grafo geralmente utilizado para representar uma hierarquia entre os v\u00e9rtices. O v\u00e9rtice mais acima \u00e9 chamado de Raiz, e a altura de cada v\u00e9rtice representa a sua dist\u00e2ncia at\u00e9 a raiz. Um v\u00e9rtice que n\u00e3o tem filhos \u00e9 chamado de Folha.</p> <p>Chamamos de floresta um grafo em que todas suas componentes s\u00e3o uma \u00e1rvore.</p> <p>\u00c1rvore cuja raiz \u00e9 o vertice A, e as folhas s\u00e3o os v\u00e9rtices C, D e F.</p> <p>Caracter\u00edsticas de \u00e1rvorre</p> <ul> <li>Um v\u00e9rtice pode ter v\u00e1rios filhos, por\u00e9m tem um \u00fanico pai.</li> <li>Possui exatamente \\(N-1\\) arestas, sendo \\(N\\) o n\u00famero de v\u00e9rtices. </li> <li>Existe apenas um caminho entre dois v\u00e9rtices. </li> <li>N\u00e3o apresenta ciclos </li> </ul>"},{"location":"start/graphs-intro/introduction/#grafos-direcionados","title":"Grafos Direcionados","text":"<p>Um grafo direcionado ou orientado \u00e9 um grafo em que suas arestas possuem um sentido. Se um par \\((U,V)\\) pertence ao conjunto \\(E\\) de arestas, ent\u00e3o existe um caminho de \\(U\\) para \\(V\\), mas n\u00e3o necessariamente existe um caminho de \\(V\\) para \\(U\\).</p> <p>Representa\u00e7\u00e3o das arestas</p> <p>No grafo direcionado, as arestas geralmente s\u00e3o representadas por setas. </p> \\[ \\begin{aligned} &amp;\\hphantom{..............} V = \\{A, B, C, D\\} \\\\ &amp;E = \\{(A, B),\\ (A, C),\\ (B, C),\\ (D, B),\\ (C, D)\\} \\end{aligned} \\] <p>No grafo acima, existe uma aresta entre os v\u00e9rtices \\(A\\) e \\(C\\), no entando n\u00e3o h\u00e1 um caminho que saia de \\(C\\) e chegue em \\(A\\). Em contrapartida, existe a aresta \\((B,C)\\) e um caminho de \\(C\\) para \\(B\\), passando pelo v\u00e9rtice \\(D\\).</p>"},{"location":"start/graphs-intro/introduction/#grafo-ponderado","title":"Grafo Ponderado","text":"<p>Um grafo ponderado \u00e9 um grafo que cada aresta possui um peso, ou seja, um valor. Formalmente, existe uma fun\u00e7\u00e3o \\(W\\) que relaciona o conjunto de arestas \\(E\\) do grafo aos numeros reais \\(\\mathbb{R}\\). Os pesos podem representar, por exemplo, custo ou dist\u00e2ncia entre os v\u00e9rtices.</p> \\[ \\begin{aligned}     W(A,B) = 1 \\\\     W(B,C) = 2 \\\\     W(B,D) = 3 \\\\     W(C,D) = 4 \\\\     W(A,C) = 5 \\end{aligned} \\]"},{"location":"start/graphs-intro/introduction/#grafo-funcional","title":"Grafo Funcional","text":"<p>\u00c9 um grafo direcionado em que cada v\u00e9rtice tem grau de sa\u00edda exatamente igual \u00e0 1.  Toda componente do grafo apresenta exatamente um ciclo.</p>"},{"location":"start/graphs-intro/introduction/#representacao-em-codigo","title":"Representa\u00e7\u00e3o em c\u00f3digo","text":"<p>Os exemplos a seguir ser\u00e3o baseados no seguinte grafo:</p>"},{"location":"start/graphs-intro/introduction/#matriz-de-adjacencia","title":"Matriz de Adjac\u00eancia","text":"<p>Representamos o grafo como uma matriz \\(M\\) de dimens\u00e3o \\(N \\times N\\), sendo \\(N\\) o n\u00famero de v\u00e9rtices. Podemos descobrir se existe uma aresta entre \\(U\\) e \\(V\\) em tempo constante apenas olhando para \\(M[U][V]\\). No entanto, a complexidade de  mem\u00f3ria \u00e9 \\(\\mathcal{O}(N^2)\\), o que pode ser invi\u00e1vel se o grafo tiver muitos v\u00e9rtices e poucas arestas (Grafos Esparsos).</p> \\[ M[U][V] = \\begin{cases} 0, &amp; (U,V) \\notin E \\\\ 1, &amp; (U,V) \\in E \\end{cases} \\] <p>Exemplo da matriz de Adjac\u00eancia do grafo desenhado anteriormente.</p> adj_matrix.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int N = 1e3+5; ///n\u00famero n\u00e1ximo de v\u00e9rtices do grafo\nint adj[N][N]; //matriz de adjac\u00eancia\nint n,m; //numero de v\u00e9rtices e arestas\n\nint main(){\n    cin&gt;&gt;n&gt;&gt;m;\n\n    for(int i=0;i&lt;m;i++){\n        int u,v;\n        cin&gt;&gt;u&gt;&gt;v;\n\n        adj[u][v] = 1;\n        adj[v][u] = 1;\n    }\n}\n</code></pre>"},{"location":"start/graphs-intro/introduction/#lista-de-adjacencia","title":"Lista de Adjac\u00eancia","text":"<p>Para todo v\u00e9rtice \\(U\\) do grafo, fazemos uma estrutura que armazena todo v\u00e9rtice \\(V\\in N(U)\\), ou seja, todo v\u00e9rtice \\(V\\) na vizinhan\u00e7a de \\(U\\). A complexidade de tempo para determinar se existe uma aresta entre os v\u00e9rtices \\(U\\) e \\(V\\) depender\u00e1 da estrutura utilizada. Em grafos esparsos, a mem\u00f3ria utilizada \u00e9 consideravelmente menor do que em matrizes de adjacencia.</p> <p>Exemplo da lista de Adjac\u00eancia do grafo desenhado anteriormente.</p> adj_list.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int N = 2e5+5; ///n\u00famero n\u00e1ximo de v\u00e9rtices do grafo\nvector&lt;int&gt; adj[N]; //lista de adjac\u00eancia\nint n,m; //numero de v\u00e9rtices e arestas\n\nint main(){\n    cin&gt;&gt;n&gt;&gt;m;\n\n    for(int i=0;i&lt;m;i++){\n        int u,v;\n        cin&gt;&gt;u&gt;&gt;v;\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n}\n</code></pre>"},{"location":"start/graphs-intro/min-path/bellmanford/","title":"Bellman-Ford","text":"1/3 \u276e \u276f"},{"location":"start/graphs-intro/min-path/bellmanford/#problemas-recomendados","title":"Problemas recomendados","text":"<ul> <li>CSES - High Score</li> <li>CSES - Cycle Finding</li> </ul>"},{"location":"start/graphs-intro/min-path/dijkstra/","title":"Dijkstra","text":"1/3 \u276e \u276f"},{"location":"start/graphs-intro/min-path/dijkstra/#problemas-recomendados","title":"Problemas recomendados","text":"<ul> <li>CSES - Shortest Routes I</li> <li>Codeforces - Dijkstra?</li> <li>CSES - Flight Discount</li> <li>CSES - Flight Routes</li> <li>CSES - Investigation </li> </ul>"},{"location":"start/graphs-intro/min-path/floydwarshall/","title":"Floyd-Warshall","text":""},{"location":"start/graphs-intro/min-path/floydwarshall/#problemas-recomendados","title":"Problemas recomendados","text":"<ul> <li>CSES - Shortest Routes II</li> </ul>"},{"location":"start/graphs-intro/mst/kruskal/","title":"Kruskal","text":"1/3 \u276e \u276f"},{"location":"start/graphs-intro/mst/prim/","title":"Prim","text":"1/3 \u276e \u276f"},{"location":"start/graphs-intro/mst/prim/#lista-de-exercicios","title":"Lista de exerc\u00edcios","text":"<p>CSES - Road Reparation Atcoder - Destruction OBI - Carro el\u00e9trico</p>"},{"location":"start/graphs-intro/search/bfs/","title":"Breadth First Search (BFS)","text":""},{"location":"start/graphs-intro/search/bfs/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>O BFS \u00e9 um algoritmo de Busca em Largura. Podemos interpretar a busca em largura como um inc\u00eandio em uma floresta. O inc\u00eancio come\u00e7a de algum foco inicial, depois, ele se espalha pelas \u00e1rvores mais pr\u00f3ximas, at\u00e9 se tornar algo quase incontrol\u00e1vel. No algoritmo de BFS, a ideia \u00e9 essencialmente a mesma: come\u00e7amos de um v\u00e9rtice inicial e andamos primeiro para todos os vizinhos pr\u00f3ximos, depois, ele se espalha para os vizinhos dos vizinhos, e assim por diante. Uma pequena ilustra\u00e7\u00e3o de como o algoritmo funciona est\u00e1 demonstrado na sequ\u00eancia de imagens abaixo.</p> 1/3 \u276e \u276f <p></p> <p>Vamos explorar melhor nessa sess\u00e3o como o BFS funciona, e quais as aplica\u00e7\u00f5es pr\u00e1ticas que podemos ter com ele.</p>"},{"location":"start/graphs-intro/search/bfs/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>N\u00f3s vamos manter uma fila, onde o topo dessa fila \u00e9 o nosso v\u00e9rtice atual. Percorreremos todos os vizinhos n\u00e3o visitados do v\u00e9rtice atual e vamos adicionar todos eles na fila tamb\u00e9m. Isso far\u00e1 com que andemos no nosso grafo em forma de n\u00edveis.</p> bfs.cpp<pre><code>const int N = 2e5+5;\nvector&lt;int&gt; graph[N]; // grafo na forma de lista de adjac\u00eancia\nvector&lt;bool&gt; vis; // saber se um v\u00e9rtice foi visitado ou n\u00e3o.\n\n\nvoid bfs(int s) {\n    queue&lt;int&gt; q; // fila para guardar os v\u00e9rtices\n    q.push(s); // colocar o v\u00e9rtice \"source\" na fila.\n    vis[s] = true; // marcar o v\u00e9rtice s\n\n    while(!q.empty()) {\n        int u = q.front(); // pegar o v\u00e9rtice no topo da fila\n        q.pop(); // retirar o v\u00e9rtice do topo da fila.\n\n        for(int v: graph[u]) { // percorrer todos os vizinhos de u\n            if(!vis[v]){ // se o v\u00e9rtice v n\u00e3o tiver sido visitado\n                vis[v] = true; // marque v como visitado\n                q.push(v); // e coloque ele na fila\n            }\n        }\n    }\n}\n</code></pre> <p>A complexidade de usar o BFS \u00e9 \\(\\mathcal{O}(N + M)\\), com \\(N\\) sendo o n\u00famero de v\u00e9rtices do nosso grafo, e \\(M\\) o n\u00famero de arestas.</p> <p>Aviso</p> <p>Um erro comum ao usar algoritmos de grafos \u00e9 n\u00e3o visitar os v\u00e9rtices. Se n\u00e3o visitar os v\u00e9rtices, a complexidade pode sair de algo linear para algo na ordem exponencial. Tomem cuidado!</p> <p>Agora, tendo a ideia do algoritmo em mente, podemos pensar em algumas aplica\u00e7\u00f5es pr\u00e1ticas do BFS em alguns problemas.</p>"},{"location":"start/graphs-intro/search/bfs/#aplicacoes","title":"Aplica\u00e7\u00f5es","text":"<p>Vamos assumir que todos os grafos podem ter at\u00e9 \\(N \\le 2\\cdot 10^{5}\\) v\u00e9rtices e \\(M \\le 2\\cdot 10^{5}\\) arestas.</p>"},{"location":"start/graphs-intro/search/bfs/#contar-componentes-conexas","title":"Contar componentes conexas","text":"<p>Dado um grafo \\(G\\), contar quantas componentes conexas ele possui.</p> <p>A ideia \u00e9 ir por cada v\u00e9rtice n\u00e3o visitado e percorrer a sua componente conexa, visitando todo mundo dela, para ela ser contabilizada somente uma vez. Ap\u00f3s percorrer todas as componentes, teremos no final a quantidade guardada em alguma vari\u00e1vel.</p> connected_component.cpp<pre><code>int components() {\n    int rs = 0; // guardar qtd de componentes\n\n    for(int i=1; i&lt;=n; i++) {\n        if(!vis[i]){\n            rs++;\n            bfs(i);\n        }\n    }\n}\n</code></pre> <p>Essencialmente, o c\u00f3digo apresentado acima \u00e9 o mesmo que o usado na sess\u00e3o de DFS, mas com um BFS no lugar. Ambos algoritmos podem ser usados para resolver o problema de contar componentes conexas, e suas variadas aplica\u00e7\u00f5es.</p>"},{"location":"start/graphs-intro/search/bfs/#caminho-minimo","title":"Caminho m\u00ednimo","text":"<p>Dado um grafo \\(G\\) sem pesos nas arestas e dois v\u00e9rtices \\(s\\) e \\(t\\), achar qual o caminho m\u00ednimo de \\(s\\) a \\(t\\). Caso ele n\u00e3o exista, exiba isso.</p> <p>Como o caminho feito pelo algoritmo \u00e9 em largura, o que acontece \u00e9 que ele tamb\u00e9m calcula a dist\u00e2ncia m\u00ednima de um v\u00e9rtice inicial para todos os outros pertencentes a mesma componente que ele, pois a ideia \u00e9 que, agora, estamos andando em n\u00edveis, e s\u00f3 iremos visitar um n\u00edvel novo quando j\u00e1 tivermos visitado todo o n\u00edvel atual. Com isso, podemos caminhar no grafo e garantir que o caminho encontrado de um v\u00e9rtice inicial a todos os outros \u00e9 o menor poss\u00edvel.</p> <p>Para a implementa\u00e7\u00e3o do algoritmo, vamos inicializar todos os valores de \\(dist[i]\\) com \\(\\infty\\), sendo que \\(\\infty\\) \u00e9 um n\u00famero muito grande. Suponha que o nosso v\u00e9rtice atual seja \\(u\\). Para todo vizinho de \\(u\\), vamos cham\u00e1-lo de \\(v\\), vamos verificar se devemos colocar ele na fila, vendo se a dist\u00e2ncia percorrida para chegar at\u00e9 ele \u00e9 menor do que a dist\u00e2ncia percorrida at\u00e9 ele atualmente, ou seja, \\(dist[v] &gt; dist[u]+1\\). Se for, atualize e coloque o v\u00e9rtice na fila.</p> <p>Se quisermos recuperar o caminho de \\(s\\) a \\(t\\), podemos guardar mais informa\u00e7\u00e3o, no caso um vetor de pais, onde olhamos quem \u00e9 pai de quem no caminho de um v\u00e9rtice a outro. Como queremos sair do v\u00e9rtice \\(s\\) at\u00e9 o \\(t\\), para recuperar o caminho, sairemos de \\(t\\) at\u00e9 \\(s\\). Abaixo ficar\u00e1 o c\u00f3digo que ilustra essa implementa\u00e7\u00e3o do caminho m\u00ednimo mais a recupera\u00e7\u00e3o do caminho.</p> min_path.cpp<pre><code>const int N = 2e5+5;\nvector&lt;int&gt; graph[N];\nint dist[N]; // usando dist\u00e2ncia.\nint pai[N]; // quem \u00e9 pai de quem\n\nvoid bfs(int s) {\n    for(int i=1; i&lt;N; i++){\n        dist[i] = N+10; // valor grande.\n        pai[i] = -1;\n    }\n\n    queue&lt;int&gt; q;\n    q.push(s);\n    dist[s] = 0;\n\n    while(!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for(int v: graph[u]) {\n            if(dist[v] &gt; dist[u]+1){\n                dist[v] = dist[u]+1;\n                pai[v] = u; // pai de v \u00e9 u.\n                q.push(v);\n            }\n        }\n    }\n}\n\n// fun\u00e7\u00e3o para recuperar o caminho de s a t.\nvector&lt;int&gt; rec_path(int t) {\n    vector&lt;int&gt; path;\n    while(t != -1) {\n        path.push_back(t);\n        t = pai[t];\n    }\n    reverse(path.begin(), path.end());\n\n    return path;\n}\n</code></pre>"},{"location":"start/graphs-intro/search/bfs/#problemas-recomendados","title":"Problemas recomendados","text":"<ul> <li>CSES - Message Route</li> <li>CSES - Counting Rooms</li> <li>CSES - Labyrinth</li> <li>CSES - Monsters</li> <li>Atcoder - Escape Route</li> <li>Codeforces - Two Buttons</li> <li>Codeforces - Gellyfish and Flaming Peony</li> <li>Codeforces - Small Operations</li> </ul>"},{"location":"start/graphs-intro/search/dfs/","title":"Depth First Search (DFS)","text":"<p>A busca em profundidade (DFS) \u00e9 uma t\u00e9cnica para percorrer grafos . Ela come\u00e7a em um v\u00e9rtice inicial e segue para um novo v\u00e9rtice adjacente que ainda n\u00e3o foi visitado. Quando n\u00e3o h\u00e1 mais v\u00e9rtices adjacentes a serem visitados, o algoritmo volta para o v\u00e9rtice anterior e tenta explorar outros caminhos.</p> 1/3 \u276e \u276f <p></p>"},{"location":"start/graphs-intro/search/dfs/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>O algoritmo pode ser implementado utilizando uma estrutura de pilha, em que o topo da pilha representa o v\u00e9rtice atual. Assim, iteramos sobre a vizinhan\u00e7a dele e adicionamos \u00e0 pilha um v\u00e9rtice adjacente ainda n\u00e3o visitado.</p> dfs_iterativo.cpp<pre><code>const int N = 2e5+5; // n\u00famero maximo de vertices\nvector&lt;int&gt;adj[N]; //lista de adjacencia\nbool vis[N]; //vetor de visitado para os vertices\n\nvoid dfs(int start){\n    stack&lt;int&gt; p;\n    p.push(start);\n\n    while(p.size()){\n        int u = p.top();\n        p.pop();\n\n        if(vis[u]) continue;\n        vis[u] = true;\n\n        for(int v: adj[u]){\n            if(!vis[v]){\n                p.push(v);\n            }\n        }\n    }\n}\n</code></pre> <p>Tamb\u00e9m podemos implementar o DFS de forma recursiva, simplificando o c\u00f3digo</p> dfs_recursivo.cpp<pre><code>void dfs(int u){\n    vis[u] = true;\n\n    for(int v: adj[u]){\n        if(!vis[v]){\n          dfs(v);\n        }\n    }\n}\n</code></pre>"},{"location":"start/graphs-intro/search/dfs/#aplicacoes","title":"Aplica\u00e7\u00f5es","text":""},{"location":"start/graphs-intro/search/dfs/#contar-componentes","title":"Contar componentes","text":""},{"location":"start/graphs-intro/search/dfs/#quantidade-de-componentes","title":"Quantidade de componentes","text":"<p>A busca em profundidade \u00e9 capaz de contar o n\u00famero de componentes conexas de um grafo. Basta iterar sobre todos os v\u00e9rtices do grafo e, para cada v\u00e9rtice ainda n\u00e3o visitado, executa-se o algoritmo para marcar os v\u00e9rtices em sua componente como visitados, somando um \u00e0 quantidade de componentes.</p> components.cpp<pre><code>int components(){\n  int qtd = 0;\n\n  for(int i=1;i&lt;=n;i++){\n    if(!vis[i]){\n      qtd++;\n      dfs(i);\n    }\n  }\n\n  return qtd;\n}\n</code></pre>"},{"location":"start/graphs-intro/search/dfs/#tamanho-de-uma-componente","title":"Tamanho de uma componente","text":"<p>Pode-se adaptar o algoritmo para retornar quantos v\u00e9rtices fazem parte de uma componente do  grafo.</p> components_size.cpp<pre><code>int dfs(int u){\n  int tam = 1;\n\n  vis[u] = true;\n\n  for(int v:adj[u]){\n    if(!vis[v]){\n      tam += dfs(v);\n    }\n  }\n\n  return tam;\n}\n</code></pre>"},{"location":"start/graphs-intro/search/dfs/#biparticao","title":"Biparti\u00e7\u00e3o","text":"<p>Para descobrir se um grafo \u00e9 bipartido e, caso for, achar sua biparti\u00e7\u00e3o, podemos rodar um DFS que carrega al\u00e9m do v\u00e9rtice atual, a cor desse v\u00e9rtice. Assim, para cada chamada da fun\u00e7\u00e3o n\u00f3s podemos inverter a cor. Caso um v\u00e9rtice tenha mesma cor de um v\u00e9rtice adjacente, o grafo n\u00e3o \u00e9 bipartido.</p> <p>A biparti\u00e7\u00e3o do grafo ficar\u00e1 guardada no vetor <code>cor</code>, em que <code>cor[u]</code> guarda se o v\u00e9rtice \\(u\\) pertence \u00e0 cor <code>0</code> ou <code>1</code>.</p> <p>Para facilitar a implementa\u00e7\u00e3o, pode-se utilizar o operador \\(xor\\) <code>^</code> para inverter a cor entre <code>0</code> e <code>1</code>, e o operador \\(and\\) <code>&amp;</code> para garantir que, caso apenas uma tentativa retorne <code>false</code>, todas as demais tamb\u00e9m ser\u00e3o falsas. </p> biparticao.cpp<pre><code>bool dfs(int u, int c){\n\n  vis[u] = true;\n  cor[u] = c;\n\n  bool ok = true;\n  for(int v:adj[u]){\n    if(!vis[v]){\n      ok &amp;= dfs(v, c ^ 1);\n    }\n\n    if(cor[v] == cor[u]){\n      return false;\n    }\n  }\n\n  return ok;\n}\n</code></pre>"},{"location":"start/graphs-intro/search/dfs/#caminho-entre-dois-vertices","title":"Caminho entre dois v\u00e9rtices","text":"<p>Podemos adicionar ao algoritmo um vetor <code>pai</code>, em que <code>pai[u]</code> guarda o v\u00e9rtice que chamou o DFS para o v\u00e9rtice <code>u</code>. Assim, executa-se o DFS a partir do v\u00e9rtice <code>v</code>. Depois basta come\u00e7ar no v\u00e9rtice <code>u</code> e ir voltando utilizando o vetor de pais at\u00e9 chegar no v\u00e9rtice <code>v</code>, guardando todo v\u00e9rtice intermedi\u00e1rio na resposta. </p> path.cpp<pre><code>void dfs(int u, int p){\n\n  vis[u] = true;\n  pai[u] = p;\n\n  for(int v:adj[u]){\n    if(!vis[v]){\n      dfs(v, u);\n    }\n  }\n}\n\nvector&lt;int&gt; find_path(int u, int v){\n  dfs(v, v);\n\n  vector&lt;int&gt; path;\n\n  if(!vis[u]) return path;\n\n  int at = u;\n  while(at != v){\n    path.push_back(at);\n    at = pai[at];\n  }\n  path.push_back(v);\n\n  return path;\n}\n</code></pre>"},{"location":"start/graphs-intro/search/dfs/#ciclos","title":"Ciclos","text":""},{"location":"start/graphs-intro/search/dfs/#grafos-nao-direcionados","title":"Grafos N\u00e3o direcionados","text":"<p>Para identificar se um grafo n\u00e3o direcionado possui um ciclo, algum v\u00e9rtice \u00e9 adjacente \u00e0 um v\u00e9rtice que j\u00e1 foi visitado anteriormente, que n\u00e3o seja o seu pai.</p> <p>Para facilitar a implementa\u00e7\u00e3o, utilizaremos o operador \\(or\\) <code>|</code>, para que caso alguma inst\u00e2ncia do DFS retorne <code>true</code>, as demais tamb\u00e9m ir\u00e3o.</p> undirected_cycle.cpp<pre><code>bool dfs(int u, int p){\n  vis[u] = true;\n\n  bool ok = false;\n  for(int v:adj[u]){\n    if(vis[v] &amp;&amp; v!=p){\n      //ciclo contendo os v\u00e9rtices u e v.\n      return true;\n    }\n\n    if(!vis[v]){\n      ok |= dfs(v, u);\n    }\n  }\n\n  return ok;\n}\n</code></pre>"},{"location":"start/graphs-intro/search/dfs/#grafos-direcionados","title":"Grafos Direcionados","text":"<p>Achar um ciclo em um grafo direcionado \u00e9 mais complexo, pois podemos chegar em um v\u00e9rtice que j\u00e1 foi visitado mas n\u00e3o faz parte de um ciclo.</p> <p>Por exemplo, no grafo abaixo, uma poss\u00edvel ordem de visita do DFS \u00e9 \\(A, B, C\\). Quando estamos no v\u00e9rtice \\(C\\), o v\u00e9rtice \\(B\\) j\u00e1 teria sido visitado, por\u00e9m ele n\u00e3o faz parte de um ciclo.</p> <p>Para resolver esse problema, iremos utilizar a seguinte colora\u00e7\u00e3o:</p> \\[ cor[u] =  \\begin{cases} 0 &amp;,\\text{ se o dfs de u n\u00e3o foi iniciado} \\\\ 1 &amp;,\\text{ se o dfs de u est\u00e1 sendo executado} \\\\ 2 &amp;,\\text{ se o dfs de u terminou de ser executado} \\\\ \\end{cases} \\] <p>Desse modo, um ciclo existe se h\u00e1 uma aresta ligando dois v\u00e9rtices de cor \\(1\\), ou seja, o DFS de dois v\u00e9rtices adjacentes ainda n\u00e3o terminou.</p> directed_cycle.cpp<pre><code>bool dfs(int u){\n  vis[u] = 1;\n  cor[u] = 1;\n\n  bool ok = false;\n  for(int v:adj[u]){\n    if(cor[v] == 1){\n      //ciclo contendo os v\u00e9rtices u e v.\n      return true;\n    }\n\n    if(!vis[v]){\n      ok |= dfs(v, u);\n    }\n  }\n\n  cor[u] = 2;\n\n  return ok;\n}\n</code></pre>"},{"location":"start/graphs-intro/search/dfs/#recuperando-um-ciclo","title":"Recuperando um ciclo","text":"<p>Para recuperar um ciclo, basta verificar a exist\u00eancia de ciclos no grafo e, caso existir, armazenar dois v\u00e9rtices \\(u\\) e \\(v\\) que fazem parte de um ciclo e recuperar o caminho de \\(u\\) at\u00e9 \\(v\\). O ciclo ser\u00e1 o mesmo caminho, por\u00e9m com uma aresta adicional, voltando para \\(u\\).</p>"},{"location":"start/graphs-intro/search/dfs/#problemas-recomendados","title":"Problemas recomendados","text":"<ul> <li>CSES - Building Roads</li> <li>CSES - Building Teams</li> <li>Atcoder - Cycle Graph?</li> <li>Atcoder - Simple Path</li> <li>CSES - Round Trip</li> <li>CSES - Round Trip II</li> <li>CSES - Course Schedule</li> </ul>"},{"location":"start/introduction/comp/","title":"Competi\u00e7\u00f5es","text":"<p>As competi\u00e7\u00f5es de programa\u00e7\u00e3o consistem em resolver um conjunto de problemas dentro de um tempo determinado. Elas podem ser individuais ou em equipe. Esses problemas s\u00e3o elaborados, solucionados e testados por \"setters\" (criadores de problemas).</p> <p>A resolu\u00e7\u00e3o de problemas em programa\u00e7\u00e3o competitiva geralmente segue duas etapas principais:</p> <p>1. Cria\u00e7\u00e3o do algoritmo: Essa fase exige habilidades de resolu\u00e7\u00e3o de problemas e intui\u00e7\u00e3o para desenvolver a l\u00f3gica por tr\u00e1s da solu\u00e7\u00e3o.</p> <p>2. Implementa\u00e7\u00e3o do algoritmo: Nesta etapa, \u00e9 preciso traduzir o algoritmo em c\u00f3digo, utilizando suas habilidades de programa\u00e7\u00e3o.</p> <p>Ap\u00f3s codificar sua solu\u00e7\u00e3o, voc\u00ea a submete a um avaliador autom\u00e1tico. Ele verifica se as respostas geradas pelo seu programa est\u00e3o corretas, comparando-as com um conjunto de casos de teste pr\u00e9-determinados. \u00c9 importante lembrar que cada problema possui limites de tempo e mem\u00f3ria que seu programa deve respeitar para ser aceito, e abordaremos isso em mais detalhes adiante.</p> <p></p> Olimp\u00edada Brasileira de Inform\u00e1tica (OBI) <p>A Olimp\u00edada Brasileira de Inform\u00e1tica (OBI) \u00e9 uma competic\u00e3o individual que acontece anualmente. O objetivo da OBI \u00e9 despertar interesse nos alunos de todas as idades pela ciencia da computa\u00e7\u00e3o. A organiza\u00e7\u00e3o da OBI est\u00e1 a cargo do instutito de computa\u00e7\u00e3o da UNICAMP.</p> <p>A OBI est\u00e1 organizada em duas modalidades, e cada modalidade \u00e9 dividida em n\u00edveis. Em todas as modalidades e n\u00edveis os alunos competem individualmente. Cada aluno poder\u00e1 ser inscrito e participar em apenas um modalidade e n\u00edvel.</p>"},{"location":"start/introduction/comp/#modalidade-iniciacao","title":"Modalidade Inicia\u00e7\u00e3o","text":"<p>Na modalidade Inicia\u00e7\u00e3o, alunos que ainda n\u00e3o sabem programar competem resolvendo problemas de l\u00f3gica e problemas de racioc\u00ednio computacional, sem uso de computador, apenas utilizando l\u00e1pis e papel. </p> <p>A modalidade Inicia\u00e7\u00e3o tem tr\u00eas n\u00edveis:</p> <ul> <li>N\u00edvel J\u00fanior, para alunos do 4\u00ba e 5\u00ba anos do Ensino Fundamental;</li> <li>N\u00edvel 1, para alunos do 6\u00ba e 7\u00ba anos do Ensino Fundamental;</li> <li>N\u00edvel 2, para alunos do 8\u00ba e 9\u00ba anos do Ensino Fundamental.</li> </ul>"},{"location":"start/introduction/comp/#modalidade-programacao","title":"Modalidade Programa\u00e7\u00e3o","text":"<p>A prova da modalidade Programa\u00e7\u00e3o exige conhecimento em programa\u00e7\u00e3o e \u00e9 necess\u00e1rio prover um computador por participante, na ocasi\u00e3o da prova. A prova \u00e9 composta de tarefas de programa\u00e7\u00e3o com n\u00edveis variados de dificuldade: h\u00e1 tarefas mais f\u00e1ceis, em que um conhecimento m\u00ednimo de programa\u00e7\u00e3o \u00e9 suficiente, e algumas tarefas mais dif\u00edceis, que exigem um conhecimento um pouco mais avan\u00e7ado de programa\u00e7\u00e3o, como no\u00e7\u00f5es de estruturas de dados, algoritmos e t\u00e9cnicas de programa\u00e7\u00e3o.</p> <p>Os n\u00edveis da Modalidade Programa\u00e7\u00e3o s\u00e3o:</p> <ul> <li>N\u00edvel J\u00fanior, para alunos de qualquer ano do Ensino Fundamental;</li> <li>N\u00edvel 1, para alunos do Ensino Fundamental ao 1\u00ba ano do Ensino M\u00e9dio;</li> <li>N\u00edvel 2, para alunos do Ensino Fundamental ao 3\u00ba ano do Ensino M\u00e9dio;</li> <li>N\u00edvel S\u00eanior, para alunos do 4\u00ba ano do Ensino T\u00e9cnico e alunos cursando pela primeira vez o 1\u00ba ano de um curso de gradua\u00e7\u00e3o.</li> </ul>"},{"location":"start/introduction/comp/#premiacao","title":"Premia\u00e7\u00e3o","text":"<p>Todos os participantes receber\u00e3o certificados de participa\u00e7\u00e3o. Os melhores colocados de cada modalidade receber\u00e3o ainda medalhas de ouro, prata e bronze.</p> <p>Para mais detalhes: https://olimpiada.ic.unicamp.br/</p>"},{"location":"start/introduction/comp/#maratona-de-programacao-da-sbc","title":"Maratona de Programa\u00e7\u00e3o da SBC","text":"<p>A Maratona de Programa\u00e7\u00e3o da SBC (Sociedade Brasileira de Computa\u00e7\u00e3o) \u00e9 uma das maiores e mais tradicionais competi\u00e7\u00f5es de programa\u00e7\u00e3o do pa\u00eds. Voltada para estudantes de gradua\u00e7\u00e3o em Computa\u00e7\u00e3o e \u00e1reas afins, a maratona ocorre anualmente e \u00e9 uma competi\u00e7\u00e3o em equipe, sendo tr\u00eas competidores e um coach. </p> <p>Mais detalhes do regulamento: https://maratona.sbc.org.br/sobre/regras.html</p> <p>A competi\u00e7\u00e3o atualmente \u00e9 dividida em tr\u00eas fases:</p>"},{"location":"start/introduction/comp/#fase-zero","title":"Fase Zero","text":"<p>A Fase Zero \u00e9 uma etapa opcional e preparat\u00f3ria da Maratona de Programa\u00e7\u00e3o da SBC, criada com o objetivo de introduzir novos participantes ao formato da competi\u00e7\u00e3o. Ela n\u00e3o \u00e9 classificator\u00f3ria, ou seja, os resultados da Fase Zero n\u00e3o influenciam na sele\u00e7\u00e3o para as pr\u00f3ximas etapas.</p>"},{"location":"start/introduction/comp/#primeira-fase","title":"Primeira Fase","text":"<p>A Primeira Fase ocorre em v\u00e1rias sedes espalhadas pelo pa\u00eds de forma simult\u00e2nea, a prova inicia \u00e0s 14:00 de Bras\u00edlia e \u00e9 disputada presencialmente. Essa fase determina os times que ocupar\u00e3o as vagas da Final Brasileira, para classificar \u00e9 necess\u00e1rio:</p> <ul> <li> <p>Estar entre os primeiros 15\u00b0 colocados da competi\u00e7\u00e3o ou</p> </li> <li> <p>Estar em uma sede e ser o melhor time da sede ou</p> </li> <li> <p>Ser um time com participa\u00e7\u00e3o feminina e estar entre os melhores colocados entre os times com participa\u00e7\u00e3o feminina. 3 vagas para os times com 3 mulheres melhor colocados; 2 vagas para os times mais bem colocados com pelo menos 2 mulheres; 1 vaga para o time melhor colocado com participa\u00e7\u00e3o feminina.</p> </li> </ul> <p>A ordem de prioridade \u00e9 Top 15 \\(\\rightarrow\\) Melhor time da sede \\(\\rightarrow\\) Feminina. Se por exemplo, uma equipe feminina se classificar entre os 15 melhores, a vaga ocupada ser\u00e1 do Top 15 e n\u00e3o uma das vagas femininas. Al\u00e9m disso, cada escola pode classificar, no m\u00e1ximo, dois times. Se por exemplo, existirem 3 times de uma mesma escola no Top 15, ent\u00e3o apenas os dois melhores s\u00e3o classificados e a d\u00e9cima sexta melhor equipe passa a fazer parte do crit\u00e9rio de classifica\u00e7\u00e3o do Top 15.</p>"},{"location":"start/introduction/comp/#final-brasileira","title":"Final Brasileira","text":"<p>A Final Brasileira \u00e9 disputada em uma sede de maneira presencial com todos os classificados da Primeira Fase. Todo ano uma sede \u00e9 definida para ser anfitri\u00e3 da competi\u00e7\u00e3o e os melhores times s\u00e3o classificados para as Finais Latino-Americanas da competi\u00e7\u00e3o.</p>"},{"location":"start/introduction/comp/#maratona-feminina-de-programacao-mfp","title":"Maratona Feminina de Programa\u00e7\u00e3o (MFP)","text":""},{"location":"start/introduction/comp/#competicoes-online","title":"Competi\u00e7\u00f5es online","text":""},{"location":"start/introduction/guide/","title":"Como funciona esse guia?","text":""},{"location":"blog/archive/2025/","title":"2025","text":""}]}