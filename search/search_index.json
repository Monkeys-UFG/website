{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bem vindo","text":""},{"location":"#monkeys-ufg","title":"Monkeys UFG","text":"<p>Bem-vindo ao site do Grupo de Programa\u00e7\u00e3o Competitiva da Universidade Federal de Goi\u00e1s (UFG)!</p> <p>Este site tem como objetivo ser um guia para estudantes interessados em participar de competi\u00e7\u00f5es de programa\u00e7\u00e3o, como a Olimp\u00edada Brasileira de Inform\u00e1tica (OBI), a Maratona SBC de Programa\u00e7\u00e3o, Maratona Feminina de Programa\u00e7\u00e3o, entre outras. Aqui, voc\u00ea encontrar\u00e1 uma cole\u00e7\u00e3o de artigos elaborados por nossos membros, al\u00e9m de diversas refer\u00eancias para o aprendizado dos t\u00f3picos mais relevantes da programa\u00e7\u00e3o competitiva.</p>"},{"location":"#um-pouco-da-historia-monkeys","title":"Um pouco da hist\u00f3ria Monkeys","text":""},{"location":"#secoes-do-site","title":"Se\u00e7\u00f5es do Site:","text":"<p>Blog: Fique por dentro das novidades, conquistas e eventos do grupo Monkeys.</p> <p>Iniciando na OBI/Maratona: Um guia completo para estudantes que querem come\u00e7ar a participar das competi\u00e7\u00f5es de programa\u00e7\u00e3o!</p> <p>Biblioteca: Biblioteca com implementa\u00e7\u00f5es de algoritmos utilizadas pelo grupo Monkeys.</p> <p>Sites: Conhe\u00e7a os principais sites para programa\u00e7\u00e3o competitiva e como aproveit\u00e1-los ao m\u00e1ximo.</p> <p>Membros: Conhe\u00e7a os integrantes do grupo Monkeys e suas contribui\u00e7\u00f5es.</p>"},{"location":"#duvidas","title":"D\u00favidas?","text":"<p>Se voc\u00ea tiver alguma d\u00favida, n\u00e3o hesite em entrar em contato conosco!</p> <p>Na UFG: Laborat\u00f3rio 252 - INF</p> <p>Online:</p> <p> </p>"},{"location":"members/","title":"Em breve...","text":""},{"location":"blog/","title":"Blog","text":""},{"location":"blog/em-breve/","title":"Em breve...","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis in nibh nunc. Aenean venenatis placerat arcu sed malesuada. Integer est lorem, tempor a est tincidunt, imperdiet malesuada nulla. Curabitur tempus elit eget nulla sagittis aliquam. Vivamus ac porttitor lorem. Mauris a finibus elit. Nunc venenatis egestas libero ac fringilla. Maecenas viverra tincidunt tellus sed ullamcorper. Morbi ornare odio nec libero aliquet hendrerit. Phasellus venenatis volutpat augue pellentesque pharetra. Maecenas id fringilla mi. Donec massa tellus, placerat id odio eu, porta vulputate erat. Donec sit amet vulputate sapien, sed tincidunt massa. Etiam commodo odio nisi, et fermentum mi faucibus id.</p>"},{"location":"library/note/","title":"Em breve...","text":""},{"location":"sites/atcoder/","title":"AtCoder","text":""},{"location":"sites/codeforces/","title":"Codeforces","text":""},{"location":"sites/cpalgo/","title":"CP-Algorithms","text":""},{"location":"sites/cses/","title":"CSES","text":""},{"location":"sites/usaco/","title":"USACO Guide","text":""},{"location":"start/binarysearch/","title":"Busca Bin\u00e1ria","text":""},{"location":"start/binarysearch/#aula-relacionada-recomendada","title":"Aula Relacionada Recomendada:","text":"C\u0155editos: Canal Maratona UFMG."},{"location":"start/binarysearch/#motivacao","title":"Motiva\u00e7\u00e3o","text":"<p>Pense no seguinte problema</p> <p>Uma f\u00e1brica possui \\(n \\) m\u00e1quinas que podem ser utilizadas para fabricar produtos. Seu objetivo \u00e9 produzir um total de \\(t \\) produtos.</p> <p>Para cada m\u00e1quina, voc\u00ea sabe quantos segundos ela leva para fabricar um \u00fanico produto. As m\u00e1quinas podem trabalhar simultaneamente, e voc\u00ea pode definir livremente o cronograma de produ\u00e7\u00e3o. Qual \u00e9 o menor tempo necess\u00e1rio para produzir \\(t \\) produtos?</p> <p>CSES - Factory Machines</p> <p>Nota</p> <p>Tente resolver o problema antes de continuar a leitura.</p>"},{"location":"start/binarysearch/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>O conceito de busca bin\u00e1ria surge quando buscamos encontrar valores em um determinado conjunto de forma r\u00e1pida e eficiente.</p> <p>Suponha que queiramos encontrar um elemento em um determinado array. Uma abordagem gen\u00e9rica consiste em usar um la\u00e7o <code>for</code> e percorrer todos os seus elementos.</p> <p>Uma poss\u00edvel implementa\u00e7\u00e3o dessa busca \u00e9 a seguinte:</p> <p>search.cpp<pre><code>for (int i = 0; i &lt; N; i++) {\n  if (array[i] == x) {\n    // elemento x encontrado no indice i;\n    cout &lt;&lt; \"ELEMENTO ENCONTRADO!\\n\";\n    break;\n  }\n}\n</code></pre> Essa abordagem, por sua vez, tem complexidade \\(O(N) \\) no pior caso. Agora, suponha que desejemos realizar \\(Q \\) consultas de elementos. Nesse cen\u00e1rio, a complexidade torna-se \\(O(N \\cdot Q) \\), o que \u00e9 invi\u00e1vel quando \\(N \\) e \\(Q \\) s\u00e3o da ordem de \\(10^5 \\).</p> <p>No entanto, h\u00e1 uma propriedade interessante: se os elementos do vetor estiverem ordenados, cada busca pode ser feita em \\(O(\\log{N}) \\).</p> <p>Na busca bin\u00e1ria, escolhemos o elemento do meio do intervalo e, a cada itera\u00e7\u00e3o, decidimos se o pr\u00f3ximo intervalo de busca ficar\u00e1 \u00e0 direita ou \u00e0 esquerda desse ponto, com base no valor do elemento que buscamos.</p> <p>A ideia pode ser vizualizada a seguir:</p> Legenda 1 1/1 \u276e \u276f <p></p> <p>A ideia apresentada anteriormente pode ser implementada da seguinte maneira:</p> <p>binarysearch.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n  // n: n\u00famero de elementos do vetor\n  // q: n\u00famero de consultas realizadas\n  int n, q;\n  cin &gt;&gt; n &gt;&gt; q;\n  vector&lt;int&gt; a(n);\n  for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; // O(n)\n\n  // ordenamos o vetor para que seja poss\u00edvel aplicar a b\u00fasca bin\u00e1ria\n  sort(a.begin(), a.end()); // O(n log n)\n\n  while(q--) {\n    // para cada consulta, buscamos o elemento x\n    int x; cin &gt;&gt; x;\n\n    // inicialmente nosso espa\u00e7o de busca \u00e9 todo o array.\n    // iniciamos find com false para que possamos identifcar facilmente  \n    // o caso em que o elemento n\u00e3o existe no array.\n    int left = 0, right = n - 1;\n    bool find = false;\n    while (left &lt;= right) {\n      int mid = (left + right) / 2;\n\n      if (a[mid] == x) {\n        find = true;\n        break;\n      } else if (a[mid] &lt; x) left = mid + 1;\n      else right = mid - 1;\n    }\n    cout &lt;&lt; (find ? \"SIM\\n\" : \"NAO\\n\");\n  } // O(q log n)\n\n  return 0;\n}\n</code></pre> Complexidade final: \\(O(N \\cdot \\log{N}) \\)</p>"},{"location":"start/binarysearch/#provando-a-complexidade","title":"Provando a complexidade","text":""},{"location":"start/binarysearch/#busca-binaria-em-funcoes-monotonas","title":"Busca Bin\u00e1ria em Fun\u00e7\u00f5es mon\u00f3tonas","text":"<p>Para al\u00e9m da simples busca de elementos, a t\u00e9cnica de busca bin\u00e1ria pode ser aplicada na resolu\u00e7\u00e3o de problemas de minimiza\u00e7\u00e3o e maximiza\u00e7\u00e3o.</p> <p>Considere uma fun\u00e7\u00e3o booleana \\(f(x) \\). Em problemas desse tipo, queremos determinar o menor (ou maior) valor de \\(x \\) para o qual \\(f(x) \\) retorna verdadeiro. Para que isso seja poss\u00edvel de forma eficiente, \u00e9 fundamental que \\(f \\) seja mon\u00f3tona. Sob essa condi\u00e7\u00e3o, todos os pontos em que \\(f(x) = true \\) aparecem agrupados em um \u00fanico intervalo cont\u00edguo.</p> <p>Ou seja: </p> <p>Para fun\u00e7\u00f5es crescente, existe um ponto de corte \\(x'\\) tal que</p> \\[   f(x) =   \\begin{cases}   \\mathtt{false}, &amp; x &lt; x',\\\\   \\mathtt{true},  &amp; x \\ge x'.   \\end{cases} \\] <p>Para fun\u00e7\u00f5es decrescente, o padr\u00e3o \u00e9 an\u00e1logo, mas com os valores invertidos:</p> \\[   f(x) =   \\begin{cases}   \\mathtt{true},  &amp; x &lt; x',\\\\   \\mathtt{false}, &amp; x \\ge x'.   \\end{cases} \\] <p>Podemos usar essa propriedade para resolver o problema motivador.</p>"},{"location":"start/binarysearch/#solucao","title":"Solu\u00e7\u00e3o:","text":"<p>O objetivo \u00e9 descobrir o menor tempo necess\u00e1rio para produzir uma quantidade \\(t\\) de produtos. Podemos converter isso em um problema de minimiza\u00e7\u00e3o definindo uma fun\u00e7\u00e3o booleana</p> \\[   f(X, t) =    \\begin{cases}   \\mathtt{true}, &amp; \\text X\\text{ segundos \u00e9 suficiente produzir pelo menos }t\\text{ produtos}.\\\\   \\mathtt{false}, &amp; \\text{caso contr\u00e1rio}.   \\end{cases} \\] <p>Para verificar se \\(X\\) segundos s\u00e3o suficientes, note que cada m\u00e1quina \\(i\\) produz \\(\\lfloor X / a_i\\rfloor\\) produtos em \\(X\\) segundos (onde \\(a_i\\) \u00e9 o tempo que a m\u00e1quina \\(i\\) leva para fabricar um \u00fanico produto). Logo, o total produzido por \\(n\\) m\u00e1quinas \u00e9</p> \\[   \\sum_{i=1}^n \\Big\\lfloor \\frac{X}{a_i}\\Big\\rfloor. \\]"},{"location":"start/binarysearch/#monotonicidade","title":"Monotonicidade","text":"<p>Para aplicar busca bin\u00e1ria, \u00e9 fundamental que \\(f(X,t)\\) seja mon\u00f3tona:</p> <ol> <li>Se \\(f(x,t)=\\mathtt{true}\\), ent\u00e3o \\(f(y,t)=\\mathtt{true}\\) para todo \\(y \\ge x\\).  </li> <li>Se \\(f(x,t)=\\mathtt{false}\\), ent\u00e3o \\(f(y,t)=\\mathtt{false}\\) para todo \\(y \\le x\\).</li> </ol> <p>Isso garante que existe um ponto de corte \\(X'\\) tal que</p> \\[   f(X,t)=   \\begin{cases}   \\mathtt{false}, &amp; X &lt; X',\\\\   \\mathtt{true},  &amp; X \\ge X',   \\end{cases} \\] <p>e podemos encontr\u00e1\u2011lo eficientemente por busca bin\u00e1ria.</p>"},{"location":"start/binarysearch/#exemplo","title":"Exemplo","text":"<p>Caso de teste: <pre><code>3 7\n3 2 5\n// 3 m\u00e1quinas, queremos produzir 7 produtos.\n// Tempos: a = [3, 2, 5]\n</code></pre></p> <p>Ao atribuir valores de \\(1\\) a \\(10\\) \u00e0 fun\u00e7\u00e3o \\(f(X, t)\\), observamos o seguinte comportamento:</p> <p><pre><code>f(1, 7) = false\nf(2, 7) = false\nf(3, 7) = false\nf(4, 7) = false\nf(5, 7) = false\nf(6, 7) = false\nf(7, 7) = false\nf(8, 7) = true\nf(9, 7) = true\nf(10, 7) = true\n</code></pre> O ponto de corte \u00e9 \\(X' = 8\\).</p> <p>O interessante \u00e9 que podemos determinar o valor \u00f3timo a partir de uma estimativa inicial, usando busca bin\u00e1ria.</p>"},{"location":"start/binarysearch/#algoritmo-por-busca-binaria","title":"Algoritmo por busca bin\u00e1ria","text":"<p>Suponha que sabemos que a resposta est\u00e1 em \\([L, R]\\). Ent\u00e3o:</p> <ol> <li> <p>Calcule \\(    mid = \\left\\lfloor \\frac{L + R}{2} \\right\\rfloor.  \\)</p> </li> <li> <p>Avalie \\(f(mid, t)\\):  </p> <ul> <li> <p>Se \\(\\mathtt{true}\\), ent\u00e3o toda solu\u00e7\u00e3o \\(\\ge mid\\) tamb\u00e9m \u00e9 verdadeira \\(\\Rightarrow \\) atualize \\(R \\leftarrow mid. \\)</p> </li> <li> <p>Se \\(\\mathtt{false}\\), ent\u00e3o toda solu\u00e7\u00e3o \\(\\le mid\\) tamb\u00e9m \u00e9 falsa \\(\\Rightarrow \\) atualize  \\(L \\leftarrow mid + 1. \\)</p> </li> </ul> </li> <li> <p>Repita at\u00e9 \\(L = R\\). Esse valor \u00e9 o \\(X'\\) \u00f3timo.</p> </li> </ol>"},{"location":"start/binarysearch/#simulacao-da-busca-binaria-caso-dado-no-exemplo","title":"Simula\u00e7\u00e3o da busca bin\u00e1ria (caso dado no exemplo):","text":"<p>A seguir, a tabela que mostra cada itera\u00e7\u00e3o com \\(L\\), \\(R\\), \\(mid = \\big\\lfloor (L+R)/2\\big\\rfloor\\), o valor de \\(f(mid,7)\\) e a a\u00e7\u00e3o tomada:</p> Itera\u00e7\u00e3o \\(L\\) \\(R\\) \\(mid = \\lfloor (L+R)/2\\rfloor\\) \\(f(mid,7)\\) A\u00e7\u00e3o 1 0 20 10 true \\(R \\leftarrow 10\\) 2 0 10 5 false \\(L \\leftarrow 6\\) 3 6 10 8 true \\(R \\leftarrow 8\\) 4 6 8 7 false \\(L \\leftarrow 8\\) 5 8 8 8 true Fim: \\(X' = 8\\) <p>Para aplicar essa abordagem, podemos considerar um limite superior maior para o intervalo, por exemplo \\( [0,\\,10^{18}] \\), e implementar o algoritmo da seguinte forma:</p> factorymachines.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint n, t;\nvector&lt;int&gt; a;\n\n/**\n  * Verifica se m segundos \u00e9 suficiente para produzir\n  * pelo menos t produtos\n  * @param m quantidade de segundos\n  * @return true caso a quantidade m de segundos seja suficiente para \n  * produzir t produtos, false caso contr\u00e1rio.\n*/\nbool check(long long m) {\n  long long sum = 0, qtd = 0;\n  for (int i = 0; i &lt; n; i++) {\n    sum += (m / a[i]);\n    // evita overflow da vari\u00e1vel sum\n    if (sum &gt;= t) return true;\n  }\n  return sum &gt;= t;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int t = 1;\n  // cin &gt;&gt; t;\n  while(t--) {\n    cin &gt;&gt; n &gt;&gt; t;\n    a.resize(n);\n\n    for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i];\n    // Intervalo inicial de tempo [0, 1e18] \n    long long l = 0, r = (long long)1e18+10, ans;\n    while (l &lt;= r) {\n      long long m = (l + r) / 2;\n\n      if (check(m)) {\n        // se check retorna true, essa quantidade de tempo \u00e9 suficiente, \n        // salvamos ela na resposta e olhamos para o intervalo [l, m - 1]\n        // em busca de um valor menor\n        ans = m;\n        r = m - 1;\n      } else l = m + 1;\n        // se check retorna false, precisamos de uma quantidade maior de tempo, \n        // olhamos pro intervalo [m + 1, r]\n    }\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n  }\n  return 0;\n}\n</code></pre>"},{"location":"start/binarysearch/#implementacoes-do-c","title":"Implementa\u00e7\u00f5es do C++","text":"<p>O C++ possui algumas implementa\u00e7\u00f5es de busca bin\u00e1ria que s\u00e3o uteis em muitos problemas: </p>"},{"location":"start/binarysearch/#lower_bound","title":"lower_bound","text":"<p>Dado um vetor ordenado, retorna um ponteiro para primeira posi\u00e7\u00e3o maior ou igual a um valor \\(X \\) procurado.</p> <p>Complexidade: \\( O(\\log{N})\\)</p> <p>Sintaxe: <pre><code>lower_bound(first, last, val)\n</code></pre> Parametros:</p> <ul> <li>first: Ponteiro pro primeiro elemento do range</li> <li>last: Ponteiro pro \u00faltimo elemento do range</li> <li>val: Valor a ser comparado.</li> </ul>"},{"location":"start/binarysearch/#exemplo_1","title":"Exemplo:","text":"lower_bound.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n  vector&lt;int&gt; a = {10, 20, 30, 30, 40, 45, 50};\n\n  // encontrando o lower bound de 35 no vetor\n  cout &lt;&lt; *lower_boud(a.begin(), a.end(), 35) &lt;&lt; '\\n';\n  // tamb\u00e9m conseguimos guardar a posi\u00e7\u00e3o \n  // do lower_bound da seguinte forma\n  int p = lower_bound(a.begin(), a.end(), 35) - a.begin();\n  cout &lt;&lt; p &lt;&lt; '\\n\\';\n}\n</code></pre>"},{"location":"start/binarysearch/#upper_bound","title":"upper_bound","text":"<p>Dado um vetor ordenado, retorna um ponteiro para primeira posi\u00e7\u00e3o estritamente maior a um valor \\(X \\) procurado.</p> <p>Complexidade: \\( O(\\log{N})\\)</p> <p>Sintaxe:</p> <pre><code>lower_bound(first, last, val)\n</code></pre> <p>Parametros:</p> <ul> <li>first: Ponteiro pro primeiro elemento do range</li> <li>last: Ponteiro pro \u00faltimo elemento do range</li> <li>val: Valor a ser comparado.</li> </ul>"},{"location":"start/binarysearch/#exemplo_2","title":"Exemplo:","text":"upper_bound.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n  vector&lt;int&gt; a = {10, 20, 30, 30, 40, 45, 50};\n\n  // encontrando o upper bound de 35 no vetor\n  cout &lt;&lt; *upper_boud(a.begin(), a.end(), 35) &lt;&lt; '\\n';\n  // tamb\u00e9m conseguimos guardar a posi\u00e7\u00e3o \n  // do upper_bound da seguinte forma\n  int p = upper_bound(a.begin(), a.end(), 35) - a.begin();\n  cout &lt;&lt; p &lt;&lt; '\\n\\';\n}\n</code></pre> <p>Para mais detalhes sobre a implementa\u00e7\u00e3o dessas fun\u00e7\u00f5es:</p> <ul> <li>lower_bound</li> <li>upper_bound</li> </ul>"},{"location":"start/bitmanipulation/","title":"Manipula\u00e7\u00e3o de Bits","text":""},{"location":"start/complexity/","title":"Complexidade de Algoritmos","text":""},{"location":"start/complexity/#aula-relacionada-recomendada","title":"Aula Relacionada recomendada:","text":"C\u0155editos: Canal Maratona UFMG."},{"location":"start/complexity/#motivacao","title":"Motiva\u00e7\u00e3o","text":"<p>Pense no seguinte problema</p> <p>Dado um array de \\(n\\) inteiros, sua tarefa \u00e9 encontrar a soma m\u00e1xima dos valores em um subarray cont\u00edguo e n\u00e3o vazio.</p> <p>CSES - Maximum Subarray Sum</p> <p>Nota</p> <p>Tente resolver o problema antes de continuar a leitura.</p> <p>Em competi\u00e7\u00f5es de programa\u00e7\u00e3o, a efici\u00eancia dos algoritmos \u00e9 crucial. Embora seja geralmente mais simples conceber uma solu\u00e7\u00e3o funcional, o verdadeiro desafio reside em otimiz\u00e1-la. Uma solu\u00e7\u00e3o ineficiente resultar\u00e1 em pouca ou nenhuma pontua\u00e7\u00e3o.</p>"},{"location":"start/complexity/#analise-de-complexidade","title":"An\u00e1lise de Complexidade","text":"<p>Queremos determinar o n\u00famero de opera\u00e7\u00f5es que um algoritmo executa em rela\u00e7\u00e3o ao tamanho da entrada, \\(n\\). Para isso, utilizamos a Nota\u00e7\u00e3o Big O, que descreve o pior caso da complexidade de tempo \u00e0 medida que \\(n\\) se aproxima do infinito. Essa nota\u00e7\u00e3o fornece um limite superior para o n\u00famero de passos que um algoritmo pode requerer, em fun\u00e7\u00e3o do tamanho da entrada.</p> <p>Quando expressamos a complexidade de uma fun\u00e7\u00e3o como \\(O(f(n))\\), geralmente omitimos fatores constantes e termos de ordem inferior de \\(f(n)\\). Veremos alguns exemplos pr\u00e1ticos de como isso funciona a seguir.</p>"},{"location":"start/complexity/#exemplos","title":"Exemplos:","text":""},{"location":"start/complexity/#operacoes-constantes","title":"Opera\u00e7\u00f5es constantes","text":"<p>O c\u00f3digo a seguir \u00e9 \\(O(1)\\), pois executa um n\u00famero constante de opera\u00e7\u00f5es.</p> <p><pre><code>int a;\ncin &gt;&gt; a;\nint b = 45;\nint c = a + b;\ncout &lt;&lt; c &lt;&lt; '\\n';\n</code></pre> Podemos assumir que opera\u00e7\u00f5es de entrada (input) e sa\u00edda (output) tamb\u00e9m s\u00e3o \\(O(1)\\).</p>"},{"location":"start/complexity/#loops","title":"Loops","text":"<p>Uma causa comum para a lentid\u00e3o de um algoritmo \u00e9 a quantidade excessiva de loops que processam a entrada. Quanto mais loops aninhados seu algoritmo contiver, mais lento ele ser\u00e1. Se houver \\(k\\) loops aninhados, a complexidade de tempo ser\u00e1 \\(O(n^k)\\).</p> <p>O c\u00f3digo a seguir tem complexidade \\(O(n)\\):</p> <pre><code>for (int i = 1; i &lt;= n; i++) {\n  // opera\u00e7\u00f5es constantes\n}\n</code></pre> <p>Como ignoramos fatores de ordem menor, o c\u00f3digo abaixo tamb\u00e9m \u00e9 \\(O(n)\\):</p> <p><pre><code>for (int i = 1; i &lt;= n + 4356; i++) {\n  // opera\u00e7\u00f5es constantes\n}\n</code></pre> Para determinar a complexidade de loops aninhados, podemos multiplicar a complexidade de cada loop:</p> <p><pre><code>for (int i = 1; i &lt;= n; i++) { // O(n)\n  for (int j = 1; j &lt;= m; j++) { // O(m)\n    // opera\u00e7\u00f5es constantes\n  }\n}\n</code></pre> Complexidade: \\(O(n \\cdot m)\\)</p> <p><pre><code>for (int i = 1; i &lt;= n; i++) { // O(n)\n  for (int j = 1; j &lt;= n; j++) { // O(n)\n    // opera\u00e7\u00f5es constantes\n  }\n}\n</code></pre> Complexidade: \\(O(n^2)\\)</p> <p>Se um algoritmo possui m\u00faltiplos blocos de c\u00f3digo, consideramos a complexidade como a pior complexidade entre todos os blocos.</p> <p><pre><code>for (int i = 1; i &lt;= n; i++) {\n  for (int j = 1; j &lt;= n; j++) {\n    // opera\u00e7\u00f5es constantes\n  }\n}\n\nfor (int i = 1; i &lt;= n; i++) {\n  // opera\u00e7\u00f5es constantes\n}\n</code></pre> Complexidade: \\(O(n^2)\\)</p> <pre><code>for (int i = 1; i &lt;= n; i++) {\n  for (int j = 1; j &lt;= n; j++) {\n    // opera\u00e7\u00f5es constantes\n  }\n}\n\nfor (int i = 1; i &lt;= m; i++) {\n  // opera\u00e7\u00f5es constantes\n}\n</code></pre> <p>Complexidade: \\(O(n^2+m)\\). Isso porque o primeiro bloco tem complexidade \\(O(n^2)\\) e o segundo tem complexidade \\(O(m)\\), e nenhuma delas \u00e9 uma fun\u00e7\u00e3o de ordem inferior em rela\u00e7\u00e3o \u00e0 outra.</p>"},{"location":"start/complexity/#recursao","title":"Recurs\u00e3o","text":"<p>A complexidade de uma fun\u00e7\u00e3o recursiva \u00e9 determinada pelo n\u00famero de vezes que a fun\u00e7\u00e3o \u00e9 chamada multiplicado pela complexidade de cada chamada.</p> <p>Considere a seguinte fun\u00e7\u00e3o: <pre><code>void f(int val, int limite) {\n  if (val == limite) return;\n  f(val + 1, limite);\n}\n\nint main() {\n  int n;\n  cin &gt;&gt; n;\n  f(1, n);\n}\n</code></pre> A chamada <code>f(1, n)</code> resulta em \\(n\\) chamadas da fun\u00e7\u00e3o, e cada uma delas tem complexidade \\(O(1)\\). Sendo assim, a complexidade total \u00e9 \\(O(n)\\).</p> <p>Agora, vejamos a pr\u00f3xima fun\u00e7\u00e3o: fibonacci.cpp<pre><code>int fib(n) {\n  if (n == 0) return 0;\n  if (n == 1) return 1;\n  return fib(n - 1) + fib(n - 2);  \n}\n\nint main() {\n  int n;\n  cin &gt;&gt; n;\n  fib(n);\n}\n</code></pre> Nesse caso, cada chamada da fun\u00e7\u00e3o <code>fib(n)</code> gera duas novas chamadas recursivas: <code>fib(n - 1)</code> e <code>fib(n - 2)</code>, exceto quando atinge os casos base, que s\u00e3o retornados diretamente sem gerar novas chamadas.</p> <p>A \u00e1rvore abaixo representa visualmente essa estrutura de chamadas para <code>fib(5)</code></p> <p>Observe que:</p> <ul> <li> <p>A \u00e1rvore cresce para a esquerda e para a direita a cada chamada, como uma \u00e1rvore bin\u00e1ria.</p> </li> <li> <p>Muitos valores s\u00e3o recalculados diversas vezes. Por exemplo, <code>fib(2)</code> \u00e9 chamado 3 vezes, <code>fib(1)</code> aparece 5 vezes.</p> </li> </ul> <p>Podemos estimar o n\u00famero total de chamadas com a soma dos n\u00f3s por n\u00edvel:</p> \\[ 1 + 2 + 4 + ... + 2^{n - 1} = 2^n-1 = O(2^n). \\] <p>Ou seja, a complexidade de tempo da vers\u00e3o recursiva de Fibonacci \u00e9 exponencial, pois o n\u00famero de chamadas cresce rapidamente com \\(n\\).</p>"},{"location":"start/complexity/#complexidades-comuns-e-restricoes","title":"Complexidades Comuns e Restri\u00e7\u00f5es","text":"<ul> <li>F\u00f3rmulas matem\u00e1ticas que apenas calculam uma resposta: \\(O(1)\\)</li> <li>Busca bin\u00e1ria: \\(O(\\log n)\\)</li> <li>Opera\u00e7\u00f5es em <code>Set</code>/<code>Map</code> ou <code>Priority Queue</code>: \\(O(\\log n)\\) por opera\u00e7\u00e3o</li> <li>Fatora\u00e7\u00e3o prima ou verifica\u00e7\u00e3o de n\u00famero primo: \\(O\\sqrt{n}\\)</li> <li>Leitura \\(n \\) itens de entrada: \\(O(n)\\) </li> <li>Itera\u00e7\u00e3o por um array ou lista de \\(n \\) elementos: \\(O(n)\\)</li> <li>Ordena\u00e7\u00e3o (Sorting): Geralmente implementado em \\(O(n \\cdot \\log n)\\) nas fun\u00e7\u00f5es de ordena\u00e7\u00e3o da linguagem.</li> <li>Iterar por todos os subconjuntos de tamanho k de uma lista: \\(O(n^k)\\)</li> <li>Iterar por todos os subconjuntos: \\(O(2^n)\\)</li> <li>Iterar por todas as permuta\u00e7\u00f5es: \\(O(n!)\\)</li> </ul> <p>Aqui est\u00e3o limites superiores conservadores para o valor de \\(n\\) para cada complexidade de tempo.</p> <p>Voc\u00ea pode conseguir um desempenho melhor em alguns casos, mas esta tabela te ajudar\u00e1 a verificar rapidamente a viabilidade de um algoritmo.</p> \\(n\\) Complexidades poss\u00edveis \\(n \\leq 10\\) \\(O(n!), O(n^7), O(n^6)\\) \\(n \\leq 20\\) \\(O(2^nn), O(n^5)\\) \\(n \\leq 80\\) \\(O(n^4)\\) \\(n \\leq 400\\) \\(O(n^3)\\) \\(n \\leq 7500\\) \\(O(n^2)\\) \\(n \\leq 7 \\cdot 10^4\\) \\(O(n \\sqrt n)\\) \\(n \\leq 5 \\cdot 10^5\\) \\(O(n \\log n)\\) \\(n \\leq 5 \\cdot 10^6\\) \\(O(n)\\) \\(n \\leq 10^{18}\\) \\(O(\\log^2 n), O(\\log n), O(1)\\) <p>Uma estimativa conservadora para o n\u00famero de opera\u00e7\u00f5es que o servidor pode lidar por segundo \u00e9 de \\(10^8\\), mas esse n\u00famero pode chegar mais pr\u00f3ximo de \\(5 \\cdot 10^8\\) se os fatores constantes forem favor\u00e1veis.</p>"},{"location":"start/complexity/#motivacao-maximum-subarray-sum","title":"Motiva\u00e7\u00e3o: Maximum Subarray Sum","text":""},{"location":"start/complexity/#1a-solucao","title":"1\u00aa Solu\u00e7\u00e3o","text":"<p>Uma maneira direta de resolver o problema \u00e9 iterar sobre todos os subarrays poss\u00edveis, calcular a soma de cada um e registrar a maior soma encontrada.</p> <p>O c\u00f3digo a seguir implementa essa abordagem: <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n  int n;\n  cin &gt;&gt; n;\n  vector&lt;int&gt; a(n);\n  for (int i = 0; i &lt; n; i++) {\n    cin &gt;&gt; a[i];\n  }\n  long long ans = 0;\n  for (int l = 0; l &lt; n; l++) {\n    for (int r = 0; r &lt; n; r++) {\n      long long sum = 0;\n      for (int k = l; k &lt;= r; k++) {\n        sum += a[k];\n      }\n      ans = max(ans, sum);\n    }\n  }\n  cout &lt;&lt; ans &lt;&lt; '\\n';\n}\n</code></pre></p> <p>A complexidade dessa solu\u00e7\u00e3o \u00e9 \\(O(n^3)\\). Como \\(n\\) pode ser da ordem de \\(2 \\cdot 10^5\\), essa abordagem se torna invi\u00e1vel para a maioria dos casos.</p>"},{"location":"start/complexity/#2a-solucao","title":"2\u00aa Solu\u00e7\u00e3o","text":"<p>Para otimizar a complexidade, podemos usar o seguinte racioc\u00ednio: vamos nos concentrar em encontrar o subarray de maior soma que termina na posi\u00e7\u00e3o \\(k\\). Existem duas possibilidades para esse subarray:</p> <ol> <li> <p>Ele cont\u00e9m apenas o elemento na posi\u00e7\u00e3o \\(k\\).</p> </li> <li> <p>Ele \u00e9 formado pelo subarray de maior soma que termina na posi\u00e7\u00e3o \\(k\u22121\\), seguido pelo elemento na posi\u00e7\u00e3o \\(k\\).</p> </li> </ol> <p>Considerando que estamos buscando a soma m\u00e1xima global, o subarray que termina na posi\u00e7\u00e3o \\(k\u22121\\) tamb\u00e9m deve ter a maior soma poss\u00edvel para que a soma total seja m\u00e1xima. Com essa ideia, podemos resolver o problema eficientemente, calculando a soma m\u00e1xima do subarray que termina em cada posi\u00e7\u00e3o, da esquerda para a direita.</p> <p>O c\u00f3digo a seguir implementa essa abordagem:</p> <p><pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n  int n;\n  cin &gt;&gt; n;\n  vector&lt;int&gt; a(n);\n  for (int i = 0; i &lt; n; i++) {\n    cin &gt;&gt; a[i];\n  }\n  long long ans = 0, sum = 0;\n  for (int k = 0; k &lt; n; k++) {\n    sum = max(a[k], sum + a[k]);\n    ans = max(ans, sum);\n  }\n  cout &lt;&lt; ans &lt;&lt; '\\n';\n}\n</code></pre> Este algoritmo possui apenas um loop que itera sobre a entrada, resultando em uma complexidade final de \\(O(n)\\). Essa abordagem \u00e9 conhecida como Algoritmo de Kadane.</p>"},{"location":"start/cpp/","title":"C++","text":"<p>Este conte\u00fado tem o intuito de apresentar uma introdu\u00e7\u00e3o \u00e0 linguagem C++, a principal linguagem utilizada em programa\u00e7\u00e3o competitiva.</p>"},{"location":"start/cpp/#por-que-c","title":"Por que C++?","text":"<p>A linguagem C++ \u00e9 amplamente utilizada em programa\u00e7\u00e3o competitiva devido \u00e0 sua alta performance. Ela permite escrever c\u00f3digos r\u00e1pidos e otimizados, o que \u00e9 crucial em competi\u00e7\u00f5es, onde o tempo de execu\u00e7\u00e3o \u00e9 um fator decisivo. Al\u00e9m disso, o C++ oferece uma vasta biblioteca padr\u00e3o (STL), que inclui estruturas de dados e algoritmos eficientes, facilitando a implementa\u00e7\u00e3o de solu\u00e7\u00f5es complexas de maneira \u00e1gil. Sua sintaxe \u00e9 relativamente simples, portanto, \u00e9 uma \u00f3tima escolha para resolver problemas.</p>"},{"location":"start/cpp/#aprendendo-a-linguagem","title":"Aprendendo a linguagem","text":"<p>Se voc\u00ea \u00e9 iniciante em programa\u00e7\u00e3o, realizar um curso sobre a linguagem pode acelerar bastante seu aprendizado. Abaixo, voc\u00ea encontrar\u00e1 conte\u00fados em v\u00eddeo e texto para apoiar seu desenvolvimento. Se voc\u00ea j\u00e1 tem experi\u00eancia com programa\u00e7\u00e3o e conhece linguagens como C, Python, Java, entre outras, recomendamos fortemente que siga o tutorial em texto, que funciona de forma mais \u00e1gil, similar a uma documenta\u00e7\u00e3o. Caso nunca tenha tido contato com programa\u00e7\u00e3o, a escolha do formato fica a seu crit\u00e9rio.</p> <p>Conte\u00fado em Texto</p> <p>O conte\u00fado em texto ser\u00e1 mais conciso e abordar\u00e1 apenas os t\u00f3picos mais importantes. Por isso, ele n\u00e3o ser\u00e1 t\u00e3o detalhado quanto o conte\u00fado em v\u00eddeo.</p>"},{"location":"start/cpp/#conteudo-em-videos-recomendado","title":"Conte\u00fado em v\u00eddeos recomendado","text":"O conte\u00fado que come\u00e7a a partir de ponteiros n\u00e3o \u00e9 obrigat\u00f3rio, mas \u00e9 \u00fatil. <p>Pro Tip</p> <p>Conhecimento sobre ponteiros, structs e classes \u00e9 \u00fatil, mas n\u00e3o \u00e9 obrigat\u00f3rio.</p>"},{"location":"start/cpp/#topicos-em-texto","title":"T\u00f3picos em texto","text":"<p>Para o conte\u00fado em texto, utilizaremos como refer\u00eancia o site W3Schools, que oferece um tutorial completo de C++. No entanto, os t\u00f3picos que ser\u00e3o mais importantes ser\u00e3o os descritos a seguir.</p> <p>W3Schools C++ Tutorial: https://www.w3schools.com/cpp/default.asp</p> <ul> <li><code>C++ Tutorial</code>, com exce\u00e7\u00e3o das se\u00e7\u00f5es <code>C++ Enums</code>, <code>C++ References</code> e <code>C++ Pointers</code>.</li> <li><code>C++ Functions</code>, com exce\u00e7\u00e3o da se\u00e7\u00e3o <code>C++ Lambda</code>.</li> <li><code>C++ How To</code>, sem exce\u00e7\u00f5es.</li> </ul> <p>As se\u00e7\u00f5es n\u00e3o citadas n\u00e3o s\u00e3o t\u00e3o relevantes.</p> <p>Para mais informa\u00e7\u00f5es: </p> <ul> <li>C++ reference: https://en.cppreference.com/w/</li> <li>cplusplus.com: https://cplusplus.com/</li> </ul>"},{"location":"start/cpp/#lista-de-exercicios","title":"Lista de Exerc\u00edcios","text":"<ul> <li>AtCoder - Doors in the Center</li> <li>AtCoder - Thermometer</li> <li>AtCoder - Triple Four</li> <li>CSES - Weird Algorithm</li> <li>CSES - Missing Number</li> <li>CSES - Repetitions</li> <li>Codeforces - Watermelon</li> <li>Codeforces - Way Too Long Words</li> <li>Codeforces - Team</li> <li>Codeforces - Bit++</li> </ul>"},{"location":"start/fenwick/","title":"Fenwick Tree","text":""},{"location":"start/geometry/","title":"Geometria","text":""},{"location":"start/greedy/","title":"Algoritmo Guloso","text":""},{"location":"start/greedy/#aula-relacionada-recomendada","title":"Aula Relacionada Recomendada:","text":"C\u0155editos: Canal Maratona UFMG."},{"location":"start/greedy/#motivacao","title":"Motiva\u00e7\u00e3o","text":"<p>Pense no seguinte problema</p> <p>Um restaurante recebeu \\(n\\) pedidos de reserva. Cada pedido reserva o restaurante por um per\u00edodo cont\u00ednuo de tempo, sendo o \\(i\\)-\u00e9simo pedido caracterizado por dois valores: o instante de in\u00edcio \\(l_i\\) e o instante de t\u00e9rmino \\(r_i\\) (com \\(l_i \\leq r_i\\)).</p> <p>A administra\u00e7\u00e3o do restaurante pode aceitar ou recusar os pedidos. Qual \u00e9 o n\u00famero m\u00e1ximo de pedidos que podem ser aceitos?</p> <p>Importante: nenhum par de pedidos aceitos pode se sobrepor, ou seja, eles n\u00e3o podem compartilhar nem mesmo um instante de tempo. Se um pedido termina exatamente no mesmo momento em que outro come\u00e7a, ambos n\u00e3o podem ser aceitos simultaneamente.</p> <p>Codeforces - Restaurant</p>"},{"location":"start/numbertheory/","title":"Teoria dos N\u00fameros","text":"<p>Teoria dos n\u00fameros \u00e9 um ramo da matem\u00e1tica que estuda n\u00fameros inteiros. Nessa se\u00e7\u00e3o, assumiremos que todos os n\u00fameros s\u00e3o inteiros.</p>"},{"location":"start/numbertheory/#divisores","title":"Divisores","text":"<p>Um n\u00famero \\(a\\) \u00e9 chamado de divisor ou fator de um n\u00famero \\(b\\) se \\(a\\) divide \\(b\\). Escrevemos \\(a \\mid b\\) e temos a seguinte propriedade:</p> \\[ b = a \\cdot k, k \\in \\mathbb{Z} \\] <p>Por exemplo, os divisores de \\(24\\) s\u00e3o \\(1, 2, 3, 4, 6, 8, 12\\) e \\(24\\).</p> \\[ 24 = 1 \\cdot 24 = 2 \\cdot 12 = 3 \\cdot 8 = \\cdots = 24 \\cdot 1 \\]"},{"location":"start/numbertheory/#primos","title":"Primos","text":"<p>Um n\u00famero \\(n &gt; 1\\) \u00e9 primo se seus \u00fanicos divisores positivos s\u00e3o \\(1\\) e \\(n\\). Por exemplo, \\(7, 19\\) e \\(41\\) s\u00e3o primos, mas 35 n\u00e3o \u00e9 primo pois \\(5 \\cdot 7 = 35\\). Para todo n\u00famero \\(n &gt; 1\\) existe uma \u00fanica fatora\u00e7\u00e3o em primos:</p> \\[ n = p_1^{\\alpha_1} p_2^{\\alpha_2} \\cdots p_k^{\\alpha_k}, \\] <p>Em que \\(p_1, p_2, ..., p_k\\) s\u00e3o primos distintos e \\(\\alpha_1, \\alpha_2, \\cdots, \\alpha_k\\) s\u00e3o inteiros positivos. Por exemplo, a fatora\u00e7\u00e3o do n\u00famero 84 \u00e9:</p> \\[     84 = 2^{2} \\cdot 3^{1} \\cdot 7^{1} \\]"},{"location":"start/numbertheory/#numero-de-divisores","title":"N\u00famero de divisores","text":"<p>O n\u00famero de divisores de um n\u00famero \\(n\\) \u00e9:</p> \\[ \\tau(n) = \\prod_{i=1}^{k} (\\alpha_i + 1), \\] <p>Porque para todo primo \\(p_i,\\) existem \\(\\alpha_i + 1\\) formas de escolher quantas vezes ele aparece no divisor, de \\(p_i^0\\) at\u00e9 \\(p_i^{\\alpha_i}\\). Por exemplo, o n\u00famero de divisores de 84 \u00e9:</p> \\[ \\tau(84) = 3 \\cdot 2 \\cdot 2 = 12. \\]"},{"location":"start/numbertheory/#soma-dos-divisores","title":"Soma dos divisores","text":"<p>A soma dos fatores de \\(n\\) \u00e9:</p> \\[ \\sigma(n) = \\prod_{i=1}^{k} (1 + p_i + \\cdots + p_i^{\\alpha_i}) = \\prod_{i=1}^{k} \\left(\\frac{p_i^{\\alpha_i+1} - 1} {p_i - 1} \\right), \\] <p>Pois podemos escolher qualquer pot\u00eancia dos primos presentes na fatora\u00e7\u00e3o de \\(n\\), de \\(p_i^{0} = 1\\) at\u00e9 \\(p_i^{\\alpha_i}\\). A simplifica\u00e7\u00e3o pode ser feita pela soma de progress\u00e3o geom\u00e9trica com raz\u00e3o \\(p_i\\):</p> \\[ \\begin{align} S &amp;= 1 + p_i + \\cdots + p_i^{\\alpha_i -1} +  p_i^{\\alpha_i} \\\\ S \\cdot p_i &amp;= p_i + p_i^{2} + \\cdots + p_i^{\\alpha_i}+ p_i^{\\alpha_i + 1} \\\\ S \\cdot p_i - S &amp;= p_i^{\\alpha_i+1} - p_i^{\\alpha_i} + p_i^{\\alpha_i} - \\cdots + \\cdots - p_i + p_i - 1 \\\\ S \\cdot (p_i - 1) &amp;= p_i^{\\alpha_i+1} - 1 \\\\ S &amp;= \\frac{p_i^{\\alpha_i+1} - 1}{p_i - 1} \\end{align} \\] <p>Por exemplo, a soma dos fatores de 84 \u00e9:</p> \\[ \\sigma(84) = \\frac{2^{3}-1}{2-1} \\cdot \\frac{3^{2}-1}{3-1} \\cdot \\frac{7^{2}}{7-1} =  7 \\cdot 4 \\cdot 8 = 224 \\]"},{"location":"start/numbertheory/#produto-dos-divisores","title":"Produto dos divisores","text":"<p>O produto dos divisores de \\(n\\) \u00e9:</p> \\[ \\mu(n) = n^{\\tau(n)/2}, \\] <p>Porque podemos formar \\(\\tau(n)/2\\) pares de divisores, cada um com produto igual \u00e0 \\(n\\). Por exemplo, os fatores de \\(84\\) produzem seis pares:</p> \\[ \\begin{align} 1 \\cdot 84 \\\\ 2 \\cdot 42 \\\\ 3 \\cdot 28 \\\\ 4 \\cdot 21 \\\\ 6 \\cdot 14 \\\\ 7 \\cdot 12  \\end{align} \\] <p>e o produto dos fatores \u00e9 \\(\\mu(84) = 84^{6} = 351298031616\\).</p>"},{"location":"start/numbertheory/#densidade-de-primos","title":"Densidade de primos","text":"<p>A densidade de n\u00fameros primos \\(\\pi(n)\\) representa a quantidade de primos entre \\(1\\) e \\(n\\). Temos a aproxima\u00e7\u00e3o:</p> \\[     \\pi(n) \\approx \\frac{n}{\\ln(n)} \\] <p>Por exemplo \\(\\pi(10) = 4,\\) pois temos \\(4\\) primos entre \\(1\\) e \\(10:\\) \\(2, 3, 5, 7\\).  </p>"},{"location":"start/numbertheory/#algoritmos-basicos","title":"Algoritmos b\u00e1sicos","text":"<p>Se um n\u00famero \\(n\\) n\u00e3o \u00e9 primo, ele pode ser representado como um produto \\(a \\cdot b,\\) em que \\(a \\leq \\sqrt{n}\\) ou \\(b \\leq \\sqrt{n}\\), portanto existe um fator entre \\(2\\) e \\(\\lfloor\\sqrt{n}\\rfloor\\). Assim, podemos testar se um n\u00famero \u00e9 primo e achar sua fatora\u00e7\u00e3o em \\(O(\\sqrt{n})\\).</p>"},{"location":"start/numbertheory/#identificar-se-um-numero-e-primo","title":"Identificar se um n\u00famero \u00e9 primo","text":"<p>A fun\u00e7\u00e3o \\(is \\_ prime\\) abaixo checa se o n\u00famero \\(n\\) \u00e9 primo. Sabemos que o \u00fanico n\u00famero par primo \u00e9 \\(2\\), portanto podemos checar a paridade de \\(n\\) e tentar dividir \\(n\\) apenas pelos n\u00fameros impares entre \\(3\\) e \\(\\lfloor \\sqrt{n} \\rfloor\\).</p> is_prime.cpp<pre><code>bool is_prime(int n) {\n    if (n &lt; 2) return false;\n    if(n%2==0) return n==2;\n\n    for (int x = 3; x*x &lt;= n; x+=2) {\n        if (n%x == 0) return false;\n    }\n\n    return true;\n}\n</code></pre>"},{"location":"start/numbertheory/#fatorar-um-numero","title":"Fatorar um n\u00famero","text":"<p>A fun\u00e7\u00e3o \\(factor\\) abaixo retorna um vetor que cont\u00e9m a fatora\u00e7\u00e3o em primos do n\u00famero \\(n\\). A fun\u00e7\u00e3o divide \\(n\\) pelos seus divisores primos e os adiciona no vector. O processo encerra quando \\(n\\) n\u00e3o tem mais fatores entre \\(2\\) e \\(\\lfloor \\sqrt{n} \\rfloor\\). Ao final do processo, se \\(n &gt; 1\\), ele \u00e9 primo e \u00e9 o \u00faltimo divisor.</p> <p>factor.cpp<pre><code>vector&lt;int&gt; factors(int n) {\n    vector&lt;int&gt; f;\n\n    for (int x = 2; x*x &lt;= n; x++) {\n        while (n%x == 0) {\n            f.push_back(x);\n            n /= x;\n        }\n    }\n    if (n &gt; 1) f.push_back(n);\n\n    return f;\n}\n</code></pre> Note que cada fator primo aparece no vetor a quantidade de vezes que ele divide o n\u00famero. Por exemplo, \\(24 = 2^3  \\cdot 3\\), portanto o resultado da fun\u00e7\u00e3o ser\u00e1 \\([2, 2, 2, 3]\\).</p>"},{"location":"start/numbertheory/#crivo-de-eratostenes","title":"Crivo de Erat\u00f3stenes","text":"<p>O crivo de Erat\u00f3stenes \u00e9 um algoritmo que constr\u00f3i um vetor no qual podemos usar de maneira eficiente para determinar se um determinado n\u00famero entre \\(0\\) e \\(n\\) \u00e9 primo. O algoritmo constr\u00f3i um vetor \\(prime\\) cujas posi\u00e7\u00f5es \\(0, 1, 2, 3, \\cdots, n\\) s\u00e3o usadas. O valor \\(prime[k] = 1\\) significa que \\(k\\) \u00e9 primo, e o valor \\(prime[k] = 0\\) significa que \\(k\\) n\u00e3o \u00e9 primo.</p> <p>O algoritmo itera sobre os n\u00fameros \\(2, \\cdots, n\\) um por um. Sempre que um novo primo \\(x\\) \u00e9 encontrado, o algoritmo guarda que os m\u00faltiplos de \\(x\\) \\((2x, 3x, 4x, \\cdots)\\) n\u00e3o s\u00e3o primos, pois s\u00e3o divis\u00edveis por x.</p> crivo.cpp<pre><code>vector&lt;int&gt; crivo(int N) {\n    vector&lt;int&gt;prime(N+1, 1);\n    prime[0] = prime[1] = 0;\n\n    for (int x = 2; x &lt;= N; x++) {\n        if(prime[x]){\n            for(int y = x+x; y &lt;= N; y+=x){\n                prime[y] = 0;\n            }\n        }\n    }\n    return prime;\n}\n</code></pre> <p>O loop interior do algoritmo \u00e9 executado \\(n/x\\) vezes para cada valor de \\(x\\). Portanto, um upper bound para a complexidade de tempo \u00e9 a s\u00e9rie harm\u00f4nica </p> \\[     \\sum_{x=2}^{n} \\frac {n}{x} = \\frac {n}{2} + \\frac {n}{3} + \\cdots + \\frac {n}{n} = O(n \\log{n}) \\] <p>Na realidade, o algoritmo \u00e9 mais eficiente, pois o loop interior vai ser executado apenas se o n\u00famero \\(x\\) \u00e9 primo, cuja frequ\u00eancia \u00e9 aproximadamente \\(\\frac{n}{\\ln(n)}\\). Portanto, a complexidade de tempo do algoritmo \u00e9 \\(O(n \\log \\log n)\\), sendo muito pr\u00f3xima de \\(O(n)\\).</p> <p>Podemos alterar o algoritmo para obter a fatora\u00e7\u00e3o de cada n\u00famero entre \\(2\\) e \\(n\\), criando um novo vetor \\(d\\) de vectors, em que \\(d[k]\\) guarda a fatora\u00e7\u00e3o em primos do n\u00famero \\(k\\).</p> crivo_div.cpp<pre><code>vector&lt;vector&lt;int&gt;&gt; crivo(int N) {\n    vector&lt;int&gt;prime(N, 1);\n    prime[0] = prime[1] = 0;\n    vector&lt;vector&lt;int&gt;&gt;d(N);\n\n    for (int x = 2; x &lt; N; x++) {\n        if(prime[x]){\n            d[x].push_back(x);\n            for(int y = x+x; y &lt; N; y+=x){\n                prime[y] = 0;\n\n                int t = y;\n                while(t%x==0){\n                    d[y].push_back(x);\n                    t/=x;\n                }\n            }\n        }\n    }\n    return d;\n}\n</code></pre>"},{"location":"start/numbertheory/#maximo-divisor-comum-mdc-ou-gcd","title":"M\u00e1ximo Divisor Comum (MDC ou GCD)","text":"<p>O m\u00e1ximo divisor comum de dois n\u00fameros \\(a\\) e \\(b\\), \\(\\gcd(a,b)\\), \u00e9 o maior n\u00famero que divide tanto \\(a\\) quanto \\(b\\). Por exemplo, \\(\\gcd(24,36) = 12\\).</p>"},{"location":"start/numbertheory/#algoritmo-de-euclides","title":"Algoritmo de Euclides","text":"<p>O algoritmo de euclides \u00e9 uma maneira eficiente de calcular o \\(\\gcd\\) de dois n\u00fameros. Ele \u00e9 baseado na seguinte f\u00f3rmula:</p> \\[ \\gcd(a,b) =  \\begin{cases} a, &amp; \\text{se } b = 0 \\\\ \\gcd(b, a \\bmod b), &amp; \\text{se } b \\neq 0  \\end{cases} \\] <p>O algoritmo de Euclides funciona em tempo \\(O(\\log n)\\), em que \\(n = \\min(a,b)\\).</p> <p>O pior caso acontece quando \\(a\\) e \\(b\\) s\u00e3o n\u00fameros consecutivos de Fibonacci. Por exemplo, \\(\\gcd(13,8) = \\gcd(8,5) = \\gcd(5,3) = \\gcd(3,2) = \\gcd(2,1) = \\gcd(1,0) = 1\\).</p> gcd.cpp<pre><code>int gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b, a%b);\n}\n</code></pre>"},{"location":"start/numbertheory/#minimo-multiplo-comum-mmc-ou-lcm","title":"M\u00ednimo m\u00faltiplo comum (MMC ou LCM)","text":"<p>O m\u00ednimo m\u00faltiplo comum de dois n\u00fameros \\(a\\) e \\(b\\), \\(lcm(a,b)\\), \u00e9 o menor n\u00famero que \u00e9 divis\u00edvel por \\(a\\) e por \\(b\\). Por exemplo, \\(lcm(24,36) = 72.\\)</p> <p>O \\(\\gcd\\) e o \\(lcm\\) possuem a seguinte propriedade:</p> \\[     lcm(a,b) = \\frac{ab}{\\gcd(a,b)} \\]"},{"location":"start/numbertheory/#funcao-totiente-de-euler","title":"Fun\u00e7\u00e3o totiente de Euler","text":"<p>N\u00fameros \\(a\\) e \\(b\\) s\u00e3o coprimos se \\(\\gcd(a,b) = 1\\). A fun\u00e7\u00e3o totiente de Euler \\(\\varphi(n)\\) calcula a quantidade de n\u00fameros coprimos com \\(n\\) entre \\(1\\) e \\(n\\). Por exemplo, \\(\\varphi(12) = 4\\), porque \\(1, 5, 7\\) e \\(11\\) s\u00e3o coprimos com \\(12\\).</p> <p>O valor de \\(\\varphi(n)\\) pode ser calculado pela fatora\u00e7\u00e3o em primos de \\(n\\) usando a formula:</p> \\[ \\varphi(n) = \\prod_{i=1}^{k} (p_i^{\\alpha_i - 1} \\cdot (p_i - 1)) \\] <p>Por exemplo, \\(\\varphi(12) = (2^1 \\cdot (2-1)) \\cdot (3^0 \\cdot (3-1)) = 4\\). </p> <p>Note que \\(\\varphi(n) = n-1\\) se \\(n\\) \u00e9 primo.</p>"},{"location":"start/numbertheory/#aritmetica-modular","title":"Aritm\u00e9tica modular","text":"<p>Na aritm\u00e9tica modular, o conjunto de n\u00fameros \u00e9 limitado para apenas \\(0, 1, 2, \\cdots, m-1\\), em que \\(m\\) \u00e9 uma constante.</p> <p>Cada n\u00famero \\(x\\) \u00e9 representado pelo n\u00famero \\(r\\) tal que </p> \\[ 0 \\le r &lt; m \\\\ \\] \\[ x = m \\cdot k + r, k \\in \\mathbb{Z} \\] <p>Por exemplo, \\(75 \\bmod 17 = 7\\).</p> <p>Pode-se calcular o m\u00f3dulo antes de algumas opera\u00e7\u00f5es para evitar n\u00fameros muito grandes. Algumas propriedades s\u00e3o:</p> \\[ \\begin{align} (x + y) \\bmod m &amp;= (x \\bmod m + y \\bmod m) \\bmod m \\\\ (x - y) \\bmod m &amp;= (x \\bmod m - y \\bmod m) \\bmod m \\\\ (x \\cdot y) \\bmod m &amp;= (x \\bmod m \\cdot y \\bmod m) \\bmod m \\\\ x^n \\bmod m &amp;= (x \\bmod m)^n \\bmod m \\end{align} \\]"},{"location":"start/numbertheory/#exponenciacao-rapida","title":"Exponencia\u00e7\u00e3o R\u00e1pida","text":"<p>Existe um jeito de calcular o valor de \\(x^n \\bmod m\\) em \\(O(\\log n)\\) utilizando a seguinte recurs\u00e3o:</p> \\[ x^n =  \\begin{cases} 1 &amp;,n = 0 \\\\ x^{n/2} \\cdot x^{n/2} &amp;, \\text{se n \u00e9 par} \\\\ x^{n-1} \\cdot x &amp;, \\text{se n \u00e9 impar}  \\end{cases} \\] <p>\u00c9 importante que no caso de \\(n\\) ser par, o valor de \\(x^{n/2}\\) \u00e9 calculado apenas uma vez. Isso garante a complexidade \\(O(\\log n)\\), porque \\(n\\) \u00e9 sempre dividido por dois quando \u00e9 par. </p> fastexp.cpp<pre><code>int fastexp(int x, int n, int m){\n    if(n==0) return 1;\n    long long p = fastexp(x, n/2, m);\n    p = (p * p) % m;\n    if(n%2 == 1) p = (p * x) % m;\n    return p;\n}\n</code></pre>"},{"location":"start/numbertheory/#pequeno-teorema-de-fermat-e-teorema-de-euler","title":"Pequeno teorema de Fermat e teorema de Euler","text":"<p>Para um \\(m\\) primo e coprimo com \\(x\\), o pequeno teorema de Fermat afirma que</p> \\[ x^{m-1} \\bmod m  = 1 \\] <p>Pode-se expandir para </p> \\[ x^k \\bmod m = x^{k \\bmod (m-1)} \\bmod m \\] <p>De forma geral, o teorema de Euler para \\(x\\) e \\(m\\) coprimos afirma que</p> \\[ x^{\\varphi (m)} \\bmod m = 1 \\] <p>O teorema de Fermat \u00e9 equivalente ao teorema de Euler, pois \\(\\varphi (m) = m-1\\) para \\(m\\) primo.</p>"},{"location":"start/numbertheory/#inverso-modular","title":"Inverso modular","text":"<p>O inverso de \\(x \\bmod m\\) \u00e9 um n\u00famero \\(x^{-1}\\) tal que</p> \\[ x \\cdot x^{-1} \\bmod m = 1 \\] <p>Usando inversos modulares, \u00e9 poss\u00edvel dividir n\u00fameros m\u00f3dulo \\(m\\), porque divis\u00e3o por \\(x\\) corresponde \u00e0 multiplica\u00e7\u00e3o por \\(x^{-1}\\).</p> <p>No entanto, o inverso modular nem sempre existe. Por exemplo, se \\(x = 2\\) e \\(m = 4\\), a equa\u00e7\u00e3o \\(x \\cdot x^{-1} \\bmod m = 1\\) n\u00e3o tem solu\u00e7\u00e3o, porque todos os m\u00faltiplos de 2 ser\u00e3o pares e o resto nunca poder\u00e1 ser \\(1\\) quando \\(m = 4\\). Temos que \\(x^{-1} \\bmod m\\) pode ser calculado apenas quando \\(x\\) e \\(m\\) s\u00e3o coprimos.</p> <p>Pelo teorema de Euler,</p> \\[ x^{\\varphi(m)} \\bmod m = x \\cdot x^{\\varphi(m) - 1} \\bmod m = 1 \\] <p>Portanto, por defini\u00e7\u00e3o, os n\u00fameros \\(x^{-1}\\) e \\(x^{\\varphi(m)-1}\\) s\u00e3o equivalentes m\u00f3dulo \\(m\\).</p> \\[ x^{-1} = x^{\\varphi(m)-1} \\bmod m \\] <p>Se \\(m\\) \u00e9 primo, obtemos</p> \\[ x^{-1} = x^{m-2} \\bmod m \\] <p>Essa f\u00f3rmula permite calcular inversos modulares de uma forma eficiente utilizando o algoritmo da exponencia\u00e7\u00e3o r\u00e1pida. </p> inverse.cpp<pre><code>int inv(int x, int m){\n    return fexp(x, m-2, m);\n}\n</code></pre> <p>Por exemplo, \\(6^{-1} \\bmod 17 = 6^{17 - 2} \\bmod 17 = 3\\). Note que \\(6 \\cdot 3 \\bmod 17 = 1\\).</p>"},{"location":"start/numbertheory/#problemas-recomendados","title":"Problemas recomendados","text":"<ul> <li>CSES - Counting Divisors</li> <li>CSES - Next Prime</li> <li>Atcoder - Div Game</li> <li>CSES - Exponentiation</li> <li>CSES - Exponentiation II</li> <li>CSES - Divisor Analysis</li> <li>CSES - Prime Multiples</li> <li>CSES - Sum of Divisors</li> <li>CSES - Common Divisors</li> <li>CSES - Counting Coprime Pairs</li> </ul>"},{"location":"start/practicing/","title":"Praticando","text":""},{"location":"start/prefixsum/","title":"Soma de prefixo","text":""},{"location":"start/prefixsum/#motivacao","title":"Motiva\u00e7\u00e3o","text":"<p>Pense no seguinte problema</p> <p>Dado um array de inteiros com \\( n \\) elementos, e \\( q \\) consultas do tipo \\( [i, j] \\), retorne a soma dos elementos do intervalo \\( [i, j] \\) do array. [1]</p> <p>Note</p> <p>Tente resolver o problema antes de continuar a leitura.</p> <p>Uma abordagem consistiria em calcular a soma de cada intervalo individualmente. Para cada consulta \\( [i, j] \\), somar\u00edamos diretamente os elementos \\( a_i + a_{i+1} + \\ldots + a_j \\). A complexidade dessa abordagem \u00e9 \\( O(n) \\) opera\u00e7\u00f5es por consulta, resultando em uma complexidade total de \\( O(nq) \\) para \\( q \\) consultas. Considerando que tanto \\( n \\) quanto \\( q \\) podem ser da ordem de \\( 10^5 \\), essa abordagem \u00e9 computacionalmente lenta.</p>"},{"location":"start/prefixsum/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Na abordagem acima possivelmente iremos realizar v\u00e1rios c\u00e1lculos repetidamente, a ideia aqui \u00e9 pr\u00e9-processar o array \\( a \\) e armazenar as somas parciais em um novo array. Seja \\( prefix \\) esse array, iremos definir \\( prefix[i] \\) como a soma dos primeiros \\( i \\) elementos do array \\( a \\).</p> <p>Assim, podemos calcular a soma de qualquer intervalo \\( [i, j] \\) em tempo constante \\( O(1) \\), coletando o valor da soma dos \\( j \\) primeiros elementos e subtraindo/removendo todos os elementos anteriores a \\( i \\), ou seja, os \\( i - 1 \\) primeiros elementos. Mostraremos que a complexidade de pr\u00e9-processamento \u00e9 \\( O(n) \\), resultando em uma complexidade total de \\( O(n + q) \\) para \\( q \\) consultas.</p>"},{"location":"start/prefixsum/#definicao","title":"Defini\u00e7\u00e3o","text":"<p>Seja \\( a \\) um array de inteiros, o array \\( prefix \\) \u00e9 definido como:</p> \\[ prefix[i] = a_1 + a_2 + \\ldots + a_{i-1} + a_i \\] <p>Ou seja:</p> \\[ prefix[i] = prefix[i - 1] + a_i \\] <p>Dessa forma, podemos calcular a soma de qualquer intervalo \\( [i, j] \\) como:</p> \\[ range(i, j) = prefix[j] - prefix[i - 1] \\] <p>Pois:</p> \\[ range(i, j) = prefix[j] - prefix[i - 1] \\] \\[ = (a_1 + a_2 + \\ldots + a_{j-1} + a_j) - (a_1 + a_2 + \\ldots + a_{i-1}) \\] \\[ = ((a_1 + a_2 + \\ldots + a_{i-1}) + (a_i + a_{i+1} + \\ldots + a_{j-1} + a_j)) - (a_1 + a_2 + \\ldots + a_{i-1}) \\] \\[ = (a_i + a_{i+1} + \\ldots + a_{j-1} + a_j) + (a_1 + a_2 + \\ldots + a_{i-1}) - (a_1 + a_2 + \\ldots + a_{i-1}) \\] \\[ = a_i + a_{i+1} + \\ldots + a_{j-1} + a_j \\]"},{"location":"start/prefixsum/#codigo","title":"C\u00f3digo","text":"<p>Esse c\u00f3digo \u00e9 um exemplo de como implementar a t\u00e9cnica de prefixo para a soma. Assim, podemos calcular o range de \\( i \\) at\u00e9 \\( j \\) como:</p> psum.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin &gt;&gt; n &gt;&gt; q;\n    vector&lt;int&gt; prefix(n + 1);\n\n    // Para evitar o caso de ind\u00edce negativo em\n    // prefix[i-1], indexaremos o array a partir de 1\n    prefix[0] = 0;\n\n    // O(n)\n    for (int i = 1; i &lt;= n; i++) {\n        int x;\n        cin &gt;&gt; x;\n        prefix[i] = prefix[i - 1] + x;\n    }\n\n    // O(q)\n    while (q--) {\n        int l, r;\n        cin &gt;&gt; l &gt;&gt; r;\n        cout &lt;&lt; prefix[r] - prefix[l - 1] &lt;&lt; '\\n';\n    }\n}\n</code></pre>"},{"location":"start/prefixsum/#outras-estruturas-algebricas","title":"Outras estruturas alg\u00e9bricas","text":"<p>Imagine que para resolver certo problema, voc\u00ea precise realizar os c\u00e1lculo de um range de um array utilizando uma opera\u00e7\u00e3o que n\u00e3o seja a de soma, como o produto ou bitwise XOR. Nessa se\u00e7\u00e3o, vamos ver como podemos generalizar o conceito de soma de prefixo para outras opera\u00e7\u00f5es e verificar se podemos ou n\u00e3o utilizar a t\u00e9cnica.</p> <p>Para isso, a rigor matem\u00e1tico, \u00e9 necess\u00e1rio que dado um conjunto \\( G \\) e uma opera\u00e7\u00e3o \\( \\star \\), \\( (G, \\star) \\) seja um grupo.</p>"},{"location":"start/prefixsum/#propriedades-de-um-grupo","title":"Propriedades de um grupo","text":"<p>\\( (G, \\star) \\) \u00e9 um grupo se, e somente se, satisfaz as seguintes propriedades:</p>"},{"location":"start/prefixsum/#fechamento","title":"Fechamento","text":"<p>Operar quaisquer dois elementos de \\( G \\) com \\( \\star \\) deve resultar em um elemento de \\( G \\)</p> \\[ \\forall x, y \\in G, x \\star y \\in G \\]"},{"location":"start/prefixsum/#associatividade","title":"Associatividade","text":"<p>A opera\u00e7\u00e3o \\( \\star \\) deve ser associativa, ou seja, a ordem de aplica\u00e7\u00e3o da opera\u00e7\u00e3o entre quaisquer tr\u00eas elementos n\u00e3o importa</p> \\[ \\forall x, y, z \\in G, (x \\star y) \\star z = x \\star (y \\star z) \\]"},{"location":"start/prefixsum/#elemento-neutro","title":"Elemento neutro","text":"<p>Deve existir um elemento \\( e \\) em \\( G \\), tal que, operar qualquer elemento \\( x \\) em \\( G \\) com \\( e \\) resulta em \\( x \\)</p> \\[ \\forall x \\in G, \\exists e \\in G : x \\star e = e \\star x = x \\]"},{"location":"start/prefixsum/#inverso","title":"Inverso","text":"<p>Deve existir um elemento \\( y \\) em \\( G \\) para cada elemento \\( x \\) em \\( G \\), tal que, operar \\( x \\) com \\( y \\) resulta no elemento neutro \\( e \\)</p> \\[ \\forall x \\in G, \\exists y \\in G : x \\star y = y \\star x = e \\] <p>Dessa forma, poderemos utilizar todo o conhecimento adquirido acima. Pois, seja:</p> \\[ prefix[i] = a_1 \\star a_2 \\star \\ldots \\star a_{i-1} \\star a_i \\] <p>Observe que \\( prefix[i] \\) pertence a \\( G \\) pela propriedade de fechamento. Dessa forma:</p> \\[ prefix[i] = prefix[i-1] \\star a_i \\] <p>Como \\( prefix[i] \\) pertence a \\( G \\), logo \\( prefix[i] \\) possui um elemento inverso, seja \\( prefix[i]^{-1} \\) esse elemento. Assim, podemos definir a opera\u00e7\u00e3o de range como:</p> \\[ range(i, j) = prefix[i-1]^{-1} \\star prefix[j] \\] <p>Pois:</p> \\[ range(i, j) = (a_1 \\star a_2 \\star \\ldots \\star a_{i-1})^{-1} \\star (a_1 \\star a_2 \\star \\ldots \\star a_{j-1} \\star a_j) \\] \\[ = (a_1 \\star a_2 \\star \\ldots \\star a_{i-1})^{-1} \\star (a_1 \\star a_2 \\star \\ldots \\star a_{i-1}) \\star (a_{i} \\star a_{i+1} \\star a_{i+2} \\star \\ldots \\star a_j) \\] \\[ = ((a_1 \\star a_2 \\star \\ldots \\star a_{i-1})^{-1} \\star (a_1 \\star a_2 \\star \\ldots \\star a_{i-1})) \\star (a_{i} \\star a_{i+1} \\star a_{i+2} \\star \\ldots \\star a_j) \\] \\[ = e \\star (a_{i} \\star a_{i+1} \\star a_{i+2} \\star \\ldots \\star a_j) \\] \\[ = a_{i} \\star a_{i+1} \\star a_{i+2} \\star \\ldots \\star a_j \\] <p>Note</p> <ul> <li>Linha 2 e 3: Associatividade</li> <li>Linha 4: Inverso</li> <li>Linha 5: Elemento neutro</li> </ul>"},{"location":"start/prefixsum/#exemplo-da-operacao-de-range","title":"Exemplo da opera\u00e7\u00e3o de range","text":"<p>Tome o array \\( \\{ a_1, a_2, a_3, a_4, a_5 \\} \\), tal que, \\( a_1, a_2, a_3, a_4, a_5 \\in G \\) e \\( (G, \\star) \\) \u00e9 um grupo e deseja calcular o \\( range(3, 5) \\):</p> \\[ range(3, 5) = prefix[2]^{-1} \\star prefix[5] \\] \\[ = (a_1 \\star a_2)^{-1} \\star (a_1 \\star a_2 \\star a_3 \\star a_4 \\star a_5) \\] \\[ = (a_1 \\star a_2)^{-1} \\star (a_1 \\star a_2) \\star (a_3 \\star a_4 \\star a_5) \\] \\[ = ((a_1 \\star a_2)^{-1} \\star (a_1 \\star a_2)) \\star (a_3 \\star a_4 \\star a_5) \\] \\[ = e \\star (a_3 \\star a_4 \\star a_5) \\] \\[ = a_3 \\star a_4 \\star a_5 \\]"},{"location":"start/prefixsum/#exemplo-de-grupos","title":"Exemplo de grupos","text":""},{"location":"start/prefixsum/#soma-nos-reais","title":"Soma nos reais","text":"<p>\\( ( \\mathbb{R}, + ) \\)</p> <ul> <li>Elemento neutro: \\( 0 \\)</li> <li>Inverso: Fun\u00e7\u00e3o de subtra\u00e7\u00e3o</li> </ul>"},{"location":"start/prefixsum/#multiplicacao-nos-inteiros","title":"Multiplica\u00e7\u00e3o nos inteiros","text":"<p>\\( ( \\mathbb{Z}, * ) \\)</p> <ul> <li>Elemento neutro: \\( 1 \\)</li> <li>Inverso: Fun\u00e7\u00e3o de divis\u00e3o</li> </ul>"},{"location":"start/prefixsum/#bitwise-xor-nos-inteiros","title":"Bitwise XOR nos inteiros","text":"<p>\\( ( \\mathbb{Z}, \\oplus ) \\)</p> <ul> <li>Elemento neutro: \\( 0 \\)</li> <li>Inverso: Fun\u00e7\u00e3o de bitwise XOR</li> </ul>"},{"location":"start/prefixsum/#codigo-geral","title":"C\u00f3digo geral","text":"<p>Esse c\u00f3digo \u00e9 um exemplo de como implementar a t\u00e9cnica de prefixo para o produto. Para isso, utilizamos o inverso da multiplica\u00e7\u00e3o, que \u00e9 a divis\u00e3o. Assim, podemos calcular o range de \\( i \\) at\u00e9 \\( j \\) como:</p> solve.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nvector&lt;double&gt; prefix;\n\ndouble neutro = 1.0;\n// elemento neutro para soma seria:\n// int neutro = 0;\n\ndouble inverso(double x) {\n    return 1.0 / x;\n    // Inverso da soma seria:\n    // return -x;\n}\n\ndouble operacao(double x, double y) {\n    return x * y;\n    // Opera\u00e7\u00e3o de soma seria:\n    // return x + y;\n}\n\ndouble range(int i, int j) {\n    return operacao(inverso(prefix[i - 1]), prefix[j]);\n}\n\nint main() {\n    int n, q;\n    cin &gt;&gt; n &gt;&gt; q;\n    prefix.resize(n + 1);\n    prefix[0] = neutro;\n\n    // O(n)\n    for (int i = 1; i &lt;= n; i++) {\n        double x;\n        cin &gt;&gt; x;\n        prefix[i] = operacao(prefix[i - 1], x);\n    }\n\n    // O(q)\n    while (q--) {\n        int l, r;\n        cin &gt;&gt; l &gt;&gt; r;\n        cout &lt;&lt; range(l, r) &lt;&lt; endl;\n    }\n}\n</code></pre>"},{"location":"start/prefixsum/#problemas-recomendados","title":"Problemas recomendados","text":"<ul> <li>Static Range Sum Queries</li> <li>Range Xor Queries</li> </ul>"},{"location":"start/segtree/","title":"Segment Tree","text":"<p>oi</p>"},{"location":"start/stl/","title":"C++ Standard Template Library (STL)","text":""},{"location":"start/stl/#aula-relacionada-recomendada","title":"Aula Relacionada recomendada","text":"C\u0155editos: Canal Maratona UFMG."},{"location":"start/stl/#conhecendo-a-stl","title":"Conhecendo a STL","text":"<p>A Standard Template Library (STL) do C++ \u00e9 um conjunto de classes e fun\u00e7\u00f5es baseadas em templates que implementam estruturas de dados e algoritmos amplamente utilizados, como listas, pilhas, vetores, ordena\u00e7\u00e3o, busca, entre outros.</p> <p>Nesta se\u00e7\u00e3o, vamos conhecer as principais estruturas e algoritmos da STL que s\u00e3o usados na programa\u00e7\u00e3o competitiva.</p> <p>As estruturas de dados mais comuns s\u00e3o:</p> Estrutura Descri\u00e7\u00e3o <code>vector</code> Armazena elementos como um array, mas pode alterar seu tamanho dinamicamente. A adi\u00e7\u00e3o e remo\u00e7\u00e3o de elementos geralmente ocorrem no final, e os elementos podem ser acessados por \u00edndice. <code>set</code> Armazena elementos \u00fanicos de forma ordenada (crescente). Elementos n\u00e3o podem ser acessados por \u00edndice. <code>map</code> Armazena elementos em pares \"chave/valor\". Pode ser acessado atrav\u00e9s das chaves, e n\u00e3o pelo \u00edndice. <code>pair</code> Armazena dois valores como um \u00fanico elemento, onde cada valor pode ter um tipo diferente. O acesso aos valores \u00e9 feito por meio de <code>first</code> e <code>second</code>. <code>stack</code> Armazena elementos em uma ordem espec\u00edfica, chamada LIFO (Last In, First Out), onde os elementos podem ser adicionados e removidos apenas do topo (como uma pilha). N\u00e3o \u00e9 acess\u00edvel por \u00edndice. <code>queue</code> Armazena elementos em uma ordem espec\u00edfica, chamada FIFO (First In, First Out), onde os elementos s\u00e3o adicionados no final e removidos da frente (como uma fila). N\u00e3o \u00e9 acess\u00edvel por \u00edndice. <code>priority_queue</code> Armazena elementos em uma ordem espec\u00edfica, os elementos de maior prioridade aparecem primeiro (por padr\u00e3o, os elementos de maior valor), \u00e9 parecido com a queue, pois voc\u00ea s\u00f3 pode acessar os elementos da frente, mas aqui a ordem \u00e9 determinada n\u00e3o pela ordem de inser\u00e7\u00e3o. N\u00e3o \u00e9 acess\u00edvel por \u00edndice. <code>deque</code> Armazena elementos em uma fila de duas extremidades (deque), onde os elementos podem ser adicionados e removidos de ambos os lados. Os elementos podem ser acessados por \u00edndice. <p>Os algoritmos mais comuns s\u00e3o:</p> Algoritmo Descri\u00e7\u00e3o <code>sort</code> Ordena os elementos em uma estrutura de dados. <code>reverse</code> Inverte a ordem dos elementos em um determinado intervalo. <code>swap</code> Troca os valores de duas vari\u00e1veis."},{"location":"start/stl/#template-basico-para-a-pratica-desta-secao","title":"Template b\u00e1sico para a pr\u00e1tica desta se\u00e7\u00e3o","text":"<p>Para facilitar nossa pr\u00e1tica nessa se\u00e7\u00e3o utilizaremos esse template simples para praticar as estruturas:</p> template.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n\n  return 0;\n}\n</code></pre>"},{"location":"start/stl/#include-bitsstdch","title":"<code>#include &lt;bits/stdc++.h&gt;</code>","text":"<p>\u00c9 um arquivo de cabe\u00e7alho que j\u00e1 inclui todas as bibliotecas padr\u00e3o, ou seja, voc\u00ea n\u00e3o precisa dar <code>#include</code> manualmente para cada estrutura de dados ou algoritmo que for usar. Por exemplo, se precisar de <code>vector</code> e <code>set</code>, normalmente teria que incluir <code>#include &lt;vector&gt;</code> e <code>#include &lt;set&gt;</code> separadamente. Com <code>#include &lt;bits/stdc++.h&gt;</code>, tudo isso j\u00e1 vem junto, facilitando o uso e economizando tempo.</p>"},{"location":"start/stl/#using-namespace-std","title":"<code>using namespace std;</code>","text":"<p>O <code>using namespace std;</code> \u00e9 uma diretiva no C++ que permite que voc\u00ea use os elementos da biblioteca padr\u00e3o (std) sem precisar escrever <code>std::</code> antes de cada um deles. Isso facilita a escrita do c\u00f3digo, pois voc\u00ea n\u00e3o precisa digitar <code>std::</code> repetidamente para acessar coisas como <code>cout</code>, <code>cin</code>, <code>vector</code>, entre outros.</p> <p>Por exemplo, se voc\u00ea n\u00e3o usar o <code>using namespace std;</code>, seria necess\u00e1rio escrever <code>std::cout</code>, <code>std::cin</code>, <code>std::vector</code>, etc. Com o <code>using namespace std;</code>, basta escrever <code>cout</code>, <code>cin</code>, <code>vector</code>, e o compilador entender\u00e1 automaticamente que voc\u00ea est\u00e1 se referindo \u00e0 vers\u00e3o padr\u00e3o dessas fun\u00e7\u00f5es e estruturas.</p>"},{"location":"start/stl/#estruturas-de-dados","title":"Estruturas de Dados","text":"<p>Em cada um dos links abaixo, voc\u00ea encontra refer\u00eancias que ensinam a utilizar cada uma das estruturas.</p> <ul> <li><code>vector</code>: https://www.geeksforgeeks.org/vector-in-cpp-stl/</li> <li><code>set</code>: https://www.geeksforgeeks.org/set-in-cpp-stl/</li> <li><code>map</code>: https://www.geeksforgeeks.org/set-in-cpp-stl/</li> <li><code>pair</code>: https://www.geeksforgeeks.org/pair-in-cpp-stl/</li> <li><code>stack</code>: https://www.geeksforgeeks.org/stack-in-cpp-stl/</li> <li><code>queue</code>: https://www.geeksforgeeks.org/queue-cpp-stl/</li> <li><code>priority_queue</code>: https://www.geeksforgeeks.org/cpp/priority-queue-in-cpp-stl/</li> <li><code>deque</code>:  https://www.geeksforgeeks.org/deque-cpp-stl/</li> </ul>"},{"location":"start/stl/#algoritmos","title":"Algoritmos","text":"<p>Em cada um dos links abaixo, voc\u00ea encontra refer\u00eancias que ensinam a utilizar cada um dos algoritmos.</p> <ul> <li><code>sort</code>: https://www.geeksforgeeks.org/sort-c-stl/</li> <li><code>reverse</code>: https://www.geeksforgeeks.org/stdreverse-in-c/</li> <li><code>swap</code>: https://www.geeksforgeeks.org/swap-in-cpp/</li> </ul> <p>Pro Tip</p> <p>Conhecer as estruturas e algoritmos b\u00e1sicos da STL v\u00e3o te ajudar bastante na sua jornada em programa\u00e7\u00e3o competitiva.</p>"},{"location":"start/stl/#lista-de-exercicios","title":"Lista de Exerc\u00edcios","text":"<ul> <li>CSES - Distinct Numbers</li> <li>OBI - Copa do Mundo</li> <li>Neps Academy - Mini Dicion\u00e1rio</li> <li>OBI - Sinuca</li> <li>OBI - Frequ\u00eancia na aula</li> <li>OBI - Zero para Cancelar</li> <li>OBI - Times</li> <li>OBI - Bombom</li> <li>OBI - Express\u00f5es</li> <li>OBI - Quebra-cabe\u00e7a</li> </ul>"},{"location":"start/twopointers/","title":"Two Pointers","text":""},{"location":"start/dp/intro/","title":"Introdu\u00e7\u00e3o","text":""},{"location":"start/dp/knapsack/","title":"Knapsack DP","text":""},{"location":"start/dp/lcs/","title":"LCS","text":""},{"location":"start/dp/paths/","title":"Caminhos em Matrizes","text":""},{"location":"start/graphs-intro/classes/","title":"Classes","text":"<p>Essa se\u00e7\u00e3o apresenta as principais classes de grafos.</p>"},{"location":"start/graphs-intro/classes/#arvore","title":"\u00c1rvore","text":"<p>Uma \u00e1rvore \u00e9 um tipo de grafo geralmente utilizado para representar uma hierarquia entre os v\u00e9rtices. O v\u00e9rtice mais acima \u00e9 chamado de Raiz, e a altura de cada v\u00e9rtice representa a sua dist\u00e2ncia at\u00e9 a raiz. Um v\u00e9rtice que n\u00e3o tem filhos \u00e9 chamado de Folha. Chamamos de floresta um grafo em que todas suas componentes conexas s\u00e3o uma \u00e1rvore.</p> <p>\u00c1rvore cuja raiz \u00e9 o vertice A, e as folhas s\u00e3o os v\u00e9rtices C, D e F.</p> <p>Caracter\u00edsticas de \u00e1rvorre</p> <ul> <li>Um v\u00e9rtice pode ter v\u00e1rios filhos, por\u00e9m tem um \u00fanico pai.</li> <li>Possui exatamente \\(N-1\\) arestas, sendo \\(N\\) o n\u00famero de v\u00e9rtices. </li> <li>Existe apenas um caminho entre dois v\u00e9rtices. </li> <li>N\u00e3o apresenta ciclos </li> </ul>"},{"location":"start/graphs-intro/classes/#grafos-direcionados","title":"Grafos Direcionados","text":"<p>Um grafo direcionado ou orientado \u00e9 um grafo em que suas arestas possuem um sentido. Se um par \\((U,V)\\) pertence ao conjunto \\(E\\) de arestas, ent\u00e3o existe um caminho de \\(U\\) para \\(V\\), mas n\u00e3o necessariamente existe um caminho de \\(V\\) para \\(U\\).</p> <p>Representa\u00e7\u00e3o das arestas</p> <p>No grafo direcionado, as arestas geralmente s\u00e3o representadas por setas. </p> \\[ \\begin{aligned} &amp;\\hphantom{..............} V = \\{A, B, C, D\\} \\\\ &amp;E = \\{(A, B),\\ (A, C),\\ (B, C),\\ (D, B),\\ (C, D)\\} \\end{aligned} \\] <p>No grafo acima, existe uma aresta entre os v\u00e9rtices \\(A\\) e \\(C\\), no entando n\u00e3o h\u00e1 um caminho que saia de \\(C\\) e chegue em \\(A\\). Em contrapartida, existe a aresta \\((B,C)\\) com um caminho saindo de \\(C\\) que chega em \\(B\\), passando pelo v\u00e9rtice \\(D\\).</p>"},{"location":"start/graphs-intro/classes/#grafo-ponderado","title":"Grafo Ponderado","text":"<p>Um grafo ponderado \u00e9 um grafo que cada aresta possui um peso, ou seja, um valor. Formalmente, existe uma fun\u00e7\u00e3o \\(W\\) que relaciona o conjunto de arestas \\(E\\) do grafo aos numeros reais \\(\\mathbb{R}\\). Os pesos podem representar, por exemplo, custo ou dist\u00e2ncia entre os v\u00e9rtices.</p> \\[ \\begin{aligned}     W(A,B) = 1 \\\\     W(B,C) = 2 \\\\     W(B,D) = 3 \\\\     W(C,D) = 4 \\\\     W(A,C) = 5 \\end{aligned} \\]"},{"location":"start/graphs-intro/classes/#grafo-funcional","title":"Grafo Funcional","text":"<p>\u00c9 um grafo direcionado em que cada v\u00e9rtice tem grau de sa\u00edda exatamente igual \u00e0 1.  Toda componente do grafo apresenta exatamente um ciclo.</p>"},{"location":"start/graphs-intro/introduction/","title":"Introdu\u00e7\u00e3o","text":"<p>Essa se\u00e7\u00e3o tem o intuito de apresentar uma introdu\u00e7\u00e3o \u00e0 Teoria dos Grafos.</p>"},{"location":"start/graphs-intro/introduction/#definicao","title":"Defini\u00e7\u00e3o","text":"<p>Um grafo \u00e9 representado por um par ordenado \\(G = (V, E)\\), em que \\(V\\) \u00e9 o conjunto de v\u00e9rtices e \\(E\\) \u00e9 o conjunto de arestas. Eles podem ser utilizados para representar rela\u00e7\u00f5es entre os v\u00e9rtices, atrav\u00e9s do uso das arestas. Por exemplo, os v\u00e9rtices podem ser vistos como cidades e as arestas como estradas, em que a aresta \\((U,V)\\) existe se h\u00e1 uma estrada entre as cidades \\(U\\) e \\(V\\).</p> <p>Os exemplos dessa se\u00e7\u00e3o ser\u00e3o baseados no seguinte grafo:</p> \\[     V = \\{A, B, C, D\\} \\] \\[     E = \\{             (A, B), (A, C),             (B, C), (B, D),             (C, D)         \\} \\]"},{"location":"start/graphs-intro/introduction/#vizinhanca","title":"Vizinhan\u00e7a","text":"<p>Definimos a vizinhan\u00e7a \\(N\\) de um v\u00e9rtice \\(V\\) como o conjunto de v\u00e9rtices que est\u00e3o ligados diretamente a \\(V\\) atrav\u00e9s de uma aresta. Em grafos direcionados, se temos a aresta \\((U,V)\\), ent\u00e3o \\(V\\in N(U)\\) e \\(U\\notin N(V)\\).  </p> \\[ N(V) = \\{U | (V,U) \\in E\\} \\] \\[ \\begin{aligned}     &amp;N(A) = \\{B,C\\} \\\\     &amp;N(B) = \\{A,C,D\\} \\\\     &amp;N(C) = \\{A,B,D\\} \\\\     &amp;N(D) = \\{B,C\\}  \\end{aligned} \\]"},{"location":"start/graphs-intro/introduction/#grau","title":"Grau","text":"<p>O grau de um v\u00e9rtice \\(V\\) \u00e9 o n\u00famero de arestas que incidem em \\(V\\). Se existe uma aresta que liga um v\u00e9rtice nele mesmo (loops), ela conta duas vezes em seu grau.  Em grafos direcionados, temos dois tipos de grau: de entrada e saida, que representam, respectivamente, o n\u00famero de arestas que entram e saem no v\u00e9rtice.</p> \\[     Deg(V) = \\left|N(V) \\right| + loops \\] \\[ \\begin{aligned} &amp;Deg(A) = 2 \\\\ &amp;Deg(B) = 3 \\\\ &amp;Deg(C) = 3 \\\\ &amp;Deg(D) = 2  \\end{aligned} \\]"},{"location":"start/graphs-intro/representation/","title":"Representa\u00e7\u00e3o","text":"<p>Nessa se\u00e7\u00e3o veremos maneiras de representar um grafo em c\u00f3digo. Os exemplos ser\u00e3o baseados no seguinte grafo:</p>"},{"location":"start/graphs-intro/representation/#matriz-de-adjacencia","title":"Matriz de Adjac\u00eancia","text":"<p>Representamos o grafo como uma matriz \\(M\\) de dimens\u00e3o \\(N*N\\), sendo \\(N\\) o n\u00famero de v\u00e9rtices. Podemos descobrir se existe uma aresta entre \\(U\\) e \\(V\\) em tempo \\(O(1)\\) apenas olhando para \\(M[U][V]\\). No entanto, a complexidade de  mem\u00f3ria \u00e9 \\(O(N^2)\\), o que pode ser invi\u00e1vel se o grafo tiver muitos v\u00e9rtices e poucas arestas (Grafos Esparsos).</p> \\[ M[U][V] = \\begin{cases} 0, &amp; (U,V) \\notin E \\\\ 1, &amp; (U,V) \\in E \\end{cases} \\] <p>Exemplo da matriz de Adjac\u00eancia do grafo desenhado anteriormente.</p> adj_matrix.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int N = 1e3+5; ///n\u00famero n\u00e1ximo de v\u00e9rtices do grafo\nint adj[N][N]; //matriz de adjac\u00eancia\nint n,m; //numero de v\u00e9rtices e arestas\n\nint main(){\n    cin&gt;&gt;n&gt;&gt;m;\n\n    for(int i=0;i&lt;m;i++){\n        int u,v;\n        cin&gt;&gt;u&gt;&gt;v;\n\n        adj[u][v] = 1;\n        adj[v][u] = 1;\n    }\n}\n</code></pre>"},{"location":"start/graphs-intro/representation/#lista-de-adjacencia","title":"Lista de Adjac\u00eancia","text":"<p>Para todo v\u00e9rtice \\(U\\) do grafo, fazemos uma estrutura que armazena todo v\u00e9rtice \\(V\\in N(U)\\), ou seja, todo v\u00e9rtice \\(V\\) na vizinhan\u00e7a de \\(U\\). A complexidade de tempo para determinar se existe uma aresta entre os v\u00e9rtices \\(U\\) e \\(V\\) depender\u00e1 da estrutura utilizada. Em grafos esparsos, a mem\u00f3ria utilizada \u00e9 consideravelmente menor do que em matrizes de adjacencia.</p> <p>Exemplo da lista de Adjac\u00eancia do grafo desenhado anteriormente.</p> adj_list.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int N = 2e5+5; ///n\u00famero n\u00e1ximo de v\u00e9rtices do grafo\nvector&lt;int&gt; adj[N]; //lista de adjac\u00eancia\nint n,m; //numero de v\u00e9rtices e arestas\n\nint main(){\n    cin&gt;&gt;n&gt;&gt;m;\n\n    for(int i=0;i&lt;m;i++){\n        int u,v;\n        cin&gt;&gt;u&gt;&gt;v;\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n}\n</code></pre>"},{"location":"start/graphs-intro/min-path/bellmanford/","title":"Bellman-Ford","text":"1/3 \u276e \u276f"},{"location":"start/graphs-intro/min-path/dijkstra/","title":"Dijkstra","text":"1/3 \u276e \u276f"},{"location":"start/graphs-intro/min-path/floydwarshall/","title":"Floyd-Warshall","text":""},{"location":"start/graphs-intro/min-path/floydwarshall/#problemas-recomendados","title":"Problemas recomendados","text":"<ul> <li>CSES - Shortest Routes II</li> </ul>"},{"location":"start/graphs-intro/mst/kruskal/","title":"Kruskal","text":"1/3 \u276e \u276f"},{"location":"start/graphs-intro/mst/prim/","title":"Prim","text":"1/3 \u276e \u276f"},{"location":"start/graphs-intro/search/bfs/","title":"Breadth First Search (BFS)","text":"1/3 \u276e \u276f"},{"location":"start/graphs-intro/search/dfs/","title":"Depth First Search (DFS)","text":"1/3 \u276e \u276f"},{"location":"start/introduction/comp/","title":"Competi\u00e7\u00f5es","text":"<p>As competi\u00e7\u00f5es de programa\u00e7\u00e3o consistem em resolver um conjunto de problemas dentro de um tempo determinado. Elas podem ser individuais ou em equipe. Esses problemas s\u00e3o elaborados, solucionados e testados por \"setters\" (criadores de problemas).</p> <p>A resolu\u00e7\u00e3o de problemas em programa\u00e7\u00e3o competitiva geralmente segue duas etapas principais:</p> <p>1. Cria\u00e7\u00e3o do algoritmo: Essa fase exige habilidades de resolu\u00e7\u00e3o de problemas e intui\u00e7\u00e3o para desenvolver a l\u00f3gica por tr\u00e1s da solu\u00e7\u00e3o.</p> <p>2. Implementa\u00e7\u00e3o do algoritmo: Nesta etapa, \u00e9 preciso traduzir o algoritmo em c\u00f3digo, utilizando suas habilidades de programa\u00e7\u00e3o.</p> <p>Ap\u00f3s codificar sua solu\u00e7\u00e3o, voc\u00ea a submete a um avaliador autom\u00e1tico. Ele verifica se as respostas geradas pelo seu programa est\u00e3o corretas, comparando-as com um conjunto de casos de teste pr\u00e9-determinados. \u00c9 importante lembrar que cada problema possui limites de tempo e mem\u00f3ria que seu programa deve respeitar para ser aceito, e abordaremos isso em mais detalhes adiante.</p> <p></p> Olimp\u00edada Brasileira de Inform\u00e1tica (OBI) <p>A Olimp\u00edada Brasileira de Inform\u00e1tica (OBI) \u00e9 uma competic\u00e3o individual que acontece anualmente. O objetivo da OBI \u00e9 despertar interesse nos alunos de todas as idades pela ciencia da computa\u00e7\u00e3o. A organiza\u00e7\u00e3o da OBI est\u00e1 a cargo do instutito de computa\u00e7\u00e3o da UNICAMP.</p> <p>A OBI est\u00e1 organizada em duas modalidades, e cada modalidade \u00e9 dividida em n\u00edveis. Em todas as modalidades e n\u00edveis os alunos competem individualmente. Cada aluno poder\u00e1 ser inscrito e participar em apenas um modalidade e n\u00edvel.</p>"},{"location":"start/introduction/comp/#modalidade-iniciacao","title":"Modalidade Inicia\u00e7\u00e3o","text":"<p>Na modalidade Inicia\u00e7\u00e3o, alunos que ainda n\u00e3o sabem programar competem resolvendo problemas de l\u00f3gica e problemas de racioc\u00ednio computacional, sem uso de computador, apenas utilizando l\u00e1pis e papel. </p> <p>A modalidade Inicia\u00e7\u00e3o tem tr\u00eas n\u00edveis:</p> <ul> <li>N\u00edvel J\u00fanior, para alunos do 4\u00ba e 5\u00ba anos do Ensino Fundamental;</li> <li>N\u00edvel 1, para alunos do 6\u00ba e 7\u00ba anos do Ensino Fundamental;</li> <li>N\u00edvel 2, para alunos do 8\u00ba e 9\u00ba anos do Ensino Fundamental.</li> </ul>"},{"location":"start/introduction/comp/#modalidade-programacao","title":"Modalidade Programa\u00e7\u00e3o","text":"<p>A prova da modalidade Programa\u00e7\u00e3o exige conhecimento em programa\u00e7\u00e3o e \u00e9 necess\u00e1rio prover um computador por participante, na ocasi\u00e3o da prova. A prova \u00e9 composta de tarefas de programa\u00e7\u00e3o com n\u00edveis variados de dificuldade: h\u00e1 tarefas mais f\u00e1ceis, em que um conhecimento m\u00ednimo de programa\u00e7\u00e3o \u00e9 suficiente, e algumas tarefas mais dif\u00edceis, que exigem um conhecimento um pouco mais avan\u00e7ado de programa\u00e7\u00e3o, como no\u00e7\u00f5es de estruturas de dados, algoritmos e t\u00e9cnicas de programa\u00e7\u00e3o.</p> <p>Os n\u00edveis da Modalidade Programa\u00e7\u00e3o s\u00e3o:</p> <ul> <li>N\u00edvel J\u00fanior, para alunos de qualquer ano do Ensino Fundamental;</li> <li>N\u00edvel 1, para alunos do Ensino Fundamental ao 1\u00ba ano do Ensino M\u00e9dio;</li> <li>N\u00edvel 2, para alunos do Ensino Fundamental ao 3\u00ba ano do Ensino M\u00e9dio;</li> <li>N\u00edvel S\u00eanior, para alunos do 4\u00ba ano do Ensino T\u00e9cnico e alunos cursando pela primeira vez o 1\u00ba ano de um curso de gradua\u00e7\u00e3o.</li> </ul>"},{"location":"start/introduction/comp/#premiacao","title":"Premia\u00e7\u00e3o","text":"<p>Todos os participantes receber\u00e3o certificados de participa\u00e7\u00e3o. Os melhores colocados de cada modalidade receber\u00e3o ainda medalhas de ouro, prata e bronze.</p> <p>Para mais detalhes: https://olimpiada.ic.unicamp.br/</p>"},{"location":"start/introduction/comp/#maratona-de-programacao-da-sbc","title":"Maratona de Programa\u00e7\u00e3o da SBC","text":"<p>A Maratona de Programa\u00e7\u00e3o da SBC (Sociedade Brasileira de Computa\u00e7\u00e3o) \u00e9 uma das maiores e mais tradicionais competi\u00e7\u00f5es de programa\u00e7\u00e3o do pa\u00eds. Voltada para estudantes de gradua\u00e7\u00e3o em Computa\u00e7\u00e3o e \u00e1reas afins, a maratona ocorre anualmente e \u00e9 uma competi\u00e7\u00e3o em equipe, sendo tr\u00eas competidores e um coach.</p> <p>A competi\u00e7\u00e3o atualmente \u00e9 dividida em tr\u00eas fases:</p>"},{"location":"start/introduction/comp/#fase-zero","title":"Fase Zero","text":"<p>A Fase Zero \u00e9 uma etapa opcional e preparat\u00f3ria da Maratona de Programa\u00e7\u00e3o da SBC, criada com o objetivo de introduzir novos participantes ao formato da competi\u00e7\u00e3o. Ela n\u00e3o \u00e9 classificator\u00f3ria, ou seja, os resultados da Fase Zero n\u00e3o influenciam na sele\u00e7\u00e3o para as pr\u00f3ximas etapas.</p>"},{"location":"start/introduction/comp/#fase-regional","title":"Fase Regional","text":""},{"location":"start/introduction/comp/#fase-nacional","title":"Fase Nacional","text":""},{"location":"start/introduction/comp/#maratona-feminina-de-programacao-mfp","title":"Maratona Feminina de Programa\u00e7\u00e3o (MFP)","text":""},{"location":"start/introduction/comp/#competicoes-online","title":"Competi\u00e7\u00f5es online","text":""},{"location":"start/introduction/guide/","title":"Como funciona esse guia?","text":""},{"location":"blog/archive/2024/","title":"2024","text":""}]}