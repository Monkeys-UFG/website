{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bem vindo","text":""},{"location":"#monkeys-ufg","title":"Monkeys UFG","text":"<p>Bem-vindo ao site do Grupo de Programa\u00e7\u00e3o Competitiva da Universidade Federal de Goi\u00e1s (UFG)!</p> <p>Este site tem como objetivo ser um guia para estudantes interessados em participar de competi\u00e7\u00f5es de programa\u00e7\u00e3o, como a Olimp\u00edada Brasileira de Inform\u00e1tica (OBI) e a Maratona SBC de Programa\u00e7\u00e3o. Aqui, voc\u00ea encontrar\u00e1 uma cole\u00e7\u00e3o de artigos elaborados por nossos membros, al\u00e9m de diversas refer\u00eancias para o aprendizado dos t\u00f3picos mais relevantes da programa\u00e7\u00e3o competitiva.</p>"},{"location":"#secoes-do-site","title":"Se\u00e7\u00f5es do Site:","text":"<p>Blog: Fique por dentro das novidades, conquistas e eventos do grupo Monkeys.</p> <p>Iniciando na OBI/Maratona: Um guia completo para estudantes que querem come\u00e7ar a participar das competi\u00e7\u00f5es de programa\u00e7\u00e3o!</p> <p>Biblioteca: Biblioteca com implementa\u00e7\u00f5es de algoritmos utilizadas pelo grupo Monkeys.</p> <p>Sites: Conhe\u00e7a os principais sites para programa\u00e7\u00e3o competitiva e como aproveit\u00e1-los ao m\u00e1ximo.</p> <p>Membros: Conhe\u00e7a os integrantes do grupo Monkeys e suas contribui\u00e7\u00f5es.</p>"},{"location":"#duvidas","title":"D\u00favidas?","text":"<p>Se voc\u00ea tiver alguma d\u00favida, n\u00e3o hesite em entrar em contato conosco!</p> <p>Na UFG: Laborat\u00f3rio 252 - INF</p> <p>Online:</p> <p> </p>"},{"location":"members/","title":"Membros","text":""},{"location":"members/#humberto","title":"HUMBERTO","text":""},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#tag:nelsi","title":"nelsi","text":"<ul> <li>            Indo pro mundial testando          </li> </ul>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/meu-primeiro-blog/","title":"Meu primeiro blog","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis in nibh nunc. Aenean venenatis placerat arcu sed malesuada. Integer est lorem, tempor a est tincidunt, imperdiet malesuada nulla. Curabitur tempus elit eget nulla sagittis aliquam. Vivamus ac porttitor lorem. Mauris a finibus elit. Nunc venenatis egestas libero ac fringilla. Maecenas viverra tincidunt tellus sed ullamcorper. Morbi ornare odio nec libero aliquet hendrerit. Phasellus venenatis volutpat augue pellentesque pharetra. Maecenas id fringilla mi. Donec massa tellus, placerat id odio eu, porta vulputate erat. Donec sit amet vulputate sapien, sed tincidunt massa. Etiam commodo odio nisi, et fermentum mi faucibus id.</p>"},{"location":"blog/indo-pro-mundial-testando/","title":"Indo pro mundial testando","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis in nibh nunc. Aenean venenatis placerat arcu sed malesuada. Integer est lorem, tempor a est tincidunt, imperdiet malesuada nulla. Curabitur tempus elit eget nulla sagittis aliquam. Vivamus ac porttitor lorem. Mauris a finibus elit. Nunc venenatis egestas libero ac fringilla. Maecenas viverra tincidunt tellus sed ullamcorper. Morbi ornare odio nec libero aliquet hendrerit. Phasellus venenatis volutpat augue pellentesque pharetra. Maecenas id fringilla mi. Donec massa tellus, placerat id odio eu, porta vulputate erat. Donec sit amet vulputate sapien, sed tincidunt massa. Etiam commodo odio nisi, et fermentum mi faucibus id.</p>","tags":["nelsi"]},{"location":"blog/third-blog/","title":"Third Blog","text":"<p>Testing</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis in nibh nunc. Aenean venenatis placerat arcu sed malesuada. Integer est lorem, tempor a est tincidunt, imperdiet malesuada nulla. Curabitur tempus elit eget nulla sagittis aliquam. Vivamus ac porttitor lorem. Mauris a finibus elit. Nunc venenatis egestas libero ac fringilla. Maecenas viverra tincidunt tellus sed ullamcorper. Morbi ornare odio nec libero aliquet hendrerit. Phasellus venenatis volutpat augue pellentesque pharetra. Maecenas id fringilla mi. Donec massa tellus, placerat id odio eu, porta vulputate erat. Donec sit amet vulputate sapien, sed tincidunt massa. Etiam commodo odio nisi, et fermentum mi faucibus id.</p>"},{"location":"library/graphs/bfs/","title":"Bfs","text":"<p>Exemplo</p>"},{"location":"sites/atcoder/","title":"AtCoder","text":""},{"location":"sites/codeforces/","title":"Codeforces","text":""},{"location":"sites/cpalgo/","title":"CP-Algorithms","text":""},{"location":"sites/cses/","title":"CSES","text":""},{"location":"sites/usaco/","title":"USACO Guide","text":""},{"location":"start/binarysearch/","title":"Busca Bin\u00e1ria","text":""},{"location":"start/binarysearch/#aula-relacionada-recomendada","title":"Aula Relacionada Recomendada:","text":"C\u0155editos: Canal Maratona UFMG."},{"location":"start/binarysearch/#busca-binaria_1","title":"Busca Bin\u00e1ria:","text":""},{"location":"start/binarysearch/#lower_bound-e-upper_bound","title":"lower_bound e upper_bound","text":""},{"location":"start/binarysearch/#busca-binaria-na-resposta","title":"Busca Bin\u00e1ria na resposta:","text":""},{"location":"start/bitmanipulation/","title":"Manipula\u00e7\u00e3o de Bits","text":""},{"location":"start/complexity/","title":"Complexidade de Algoritmos","text":"<p>TESTANDO LATEX:</p> \\[ \\cos x=\\sum_{k=0}^{\\infty}\\frac{(-1)^k}{(2k)!}x^{2k} \\] <p>The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\), because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\).</p>"},{"location":"start/cpp/","title":"C++","text":"<p>Este conte\u00fado tem o intuito de apresentar uma introdu\u00e7\u00e3o \u00e0 linguagem C++, a principal linguagem utilizada em programa\u00e7\u00e3o competitiva.</p>"},{"location":"start/cpp/#por-que-c","title":"Por que C++?","text":"<p>A linguagem C++ \u00e9 amplamente utilizada em programa\u00e7\u00e3o competitiva devido \u00e0 sua alta performance. Ela permite escrever c\u00f3digos r\u00e1pidos e otimizados, o que \u00e9 crucial em competi\u00e7\u00f5es, onde o tempo de execu\u00e7\u00e3o \u00e9 um fator decisivo. Al\u00e9m disso, o C++ oferece uma vasta biblioteca padr\u00e3o (STL), que inclui estruturas de dados e algoritmos eficientes, facilitando a implementa\u00e7\u00e3o de solu\u00e7\u00f5es complexas de maneira \u00e1gil. Sua sintaxe \u00e9 relativamente simples, portanto, \u00e9 uma \u00f3tima escolha para resolver problemas.</p>"},{"location":"start/cpp/#aprendendo-a-linguagem","title":"Aprendendo a linguagem","text":"<p>Se voc\u00ea \u00e9 iniciante em programa\u00e7\u00e3o, realizar um curso sobre a linguagem pode acelerar bastante seu aprendizado. Abaixo, voc\u00ea encontrar\u00e1 conte\u00fados em v\u00eddeo e texto para apoiar seu desenvolvimento. Se voc\u00ea j\u00e1 tem experi\u00eancia com programa\u00e7\u00e3o e conhece linguagens como C, Python, Java, entre outras, recomendamos fortemente que siga o tutorial em texto, que funciona de forma mais \u00e1gil, similar a uma documenta\u00e7\u00e3o. Caso nunca tenha tido contato com programa\u00e7\u00e3o, a escolha do formato fica a seu crit\u00e9rio.</p> <p>Conte\u00fado em Texto</p> <p>O conte\u00fado em texto ser\u00e1 mais conciso e abordar\u00e1 apenas os t\u00f3picos mais importantes. Por isso, ele n\u00e3o ser\u00e1 t\u00e3o detalhado quanto o conte\u00fado em v\u00eddeo.</p>"},{"location":"start/cpp/#conteudo-em-videos-recomendado","title":"Conte\u00fado em v\u00eddeos recomendado:","text":"<p>Link</p> <p>Pro Tip</p> <p>Conhecimento sobre ponteiros, structs e classes \u00e9 \u00fatil, mas n\u00e3o \u00e9 obrigat\u00f3rio.</p>"},{"location":"start/cpp/#topicos-em-texto","title":"T\u00f3picos em texto:","text":"<p>Para o conte\u00fado em texto, utilizaremos como refer\u00eancia o site W3Schools, que oferece um tutorial completo de C++. No entanto, abordaremos apenas os t\u00f3picos listados a seguir.</p> <p>W3Schools C++ Tutorial: https://www.w3schools.com/cpp/default.asp</p> <ul> <li><code>C++ Tutorial</code>, com exce\u00e7\u00e3o das se\u00e7\u00f5es <code>C++ Enums</code>, <code>C++ References</code> e <code>C++ Pointers</code>.</li> <li><code>C++ Functions</code>, sem exce\u00e7\u00f5es.</li> <li><code>C++ How To</code>, sem exce\u00e7\u00f5es.</li> </ul> <p>As se\u00e7\u00f5es n\u00e3o mencionadas podem ser ignoradas.</p>"},{"location":"start/cpp/#lista-de-exercicios","title":"Lista de Exerc\u00edcios:","text":"<ul> <li>AtCoder - Doors in the Center</li> <li>AtCoder - Thermometer</li> <li>AtCoder - Triple Four</li> <li>CSES - Weird Algorithm</li> <li>CSES - Missing Number</li> <li>CSES - Repetitions</li> <li>Codeforces - Watermelon</li> <li>Codeforces - Way Too Long Words</li> <li>Codeforces - Team</li> <li>Codeforces - Bit++</li> <li>Codeforces - Next Round</li> <li>Codeforces - Domino piling</li> <li>Codeforces - Helpful Maths</li> <li>Codeforces - Boy or Girl</li> <li>Codeforces - Word Capitalization</li> <li>Codeforces - Bear and Big Brother</li> <li>Codeforces - Stones on the Table</li> <li>Codeforces - Elephant</li> <li>Codeforces - Soldier and Bananas</li> <li>Codeforces - Word</li> </ul> <p>Para mais informa\u00e7\u00f5es: </p> <ul> <li>C++ reference: https://en.cppreference.com/w/</li> <li>cplusplus.com: https://cplusplus.com/</li> </ul>"},{"location":"start/dp/","title":"Programa\u00e7\u00e3o Din\u00e2mica","text":""},{"location":"start/fenwick/","title":"Fenwick Tree","text":""},{"location":"start/geometry/","title":"Geometria","text":""},{"location":"start/greedy/","title":"Algoritmo Guloso","text":""},{"location":"start/intro/","title":"Introdu\u00e7\u00e3o","text":"<p>Falar sobre a maratona e explicar o guia</p>"},{"location":"start/intro/#informacoes","title":"Informa\u00e7\u00f5es","text":""},{"location":"start/numbertheory/","title":"Teoria dos N\u00fameros","text":""},{"location":"start/practicing/","title":"Praticando","text":""},{"location":"start/prefixsum/","title":"Soma de prefixo","text":""},{"location":"start/prefixsum/#motivacao","title":"Motiva\u00e7\u00e3o","text":"<p>Pense no seguinte problema</p> <p>Dado um array de inteiros com \\( n \\) elementos, e \\( q \\) consultas do tipo \\( [i, j] \\), retorne a soma dos elementos do intervalo \\( [i, j] \\) do array. [1]</p> <p>Note</p> <p>Tente resolver o problema antes de continuar a leitura.</p> <p>Uma abordagem consistiria em calcular a soma de cada intervalo individualmente. Para cada consulta \\( [i, j] \\), somar\u00edamos diretamente os elementos \\( a_i + a_{i+1} + \\ldots + a_j \\). A complexidade dessa abordagem \u00e9 \\( O(n) \\) opera\u00e7\u00f5es por consulta, resultando em uma complexidade total de \\( O(nq) \\) para \\( q \\) consultas. Considerando que tanto \\( n \\) quanto \\( q \\) podem ser da ordem de \\( 10^5 \\), essa abordagem \u00e9 computacionalmente lenta.</p>"},{"location":"start/prefixsum/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Na abordagem acima possivelmente iremos realizar v\u00e1rios c\u00e1lculos repetidamente, a ideia aqui \u00e9 pr\u00e9-processar o array \\( a \\) e armazenar as somas parciais em um novo array. Seja \\( prefix \\) esse array, iremos definir \\( prefix[i] \\) como a soma dos primeiros \\( i \\) elementos do array \\( a \\).</p> <p>Assim, podemos calcular a soma de qualquer intervalo \\( [i, j] \\) em tempo constante \\( O(1) \\), coletando o valor da soma dos \\( j \\) primeiros elementos e subtraindo/removendo todos os elementos anteriores a \\( i \\), ou seja, os \\( i - 1 \\) primeiros elementos. Mostraremos que a complexidade de pr\u00e9-processamento \u00e9 \\( O(n) \\), resultando em uma complexidade total de \\( O(n + q) \\) para \\( q \\) consultas.</p>"},{"location":"start/prefixsum/#definicao","title":"Defini\u00e7\u00e3o","text":"<p>Seja \\( a \\) um array de inteiros, o array \\( prefix \\) \u00e9 definido como:</p> \\[ prefix[i] = a_1 + a_2 + \\ldots + a_{i-1} + a_i \\] <p>Ou seja:</p> \\[ prefix[i] = prefix[i - 1] + a_i \\] <p>Dessa forma, podemos calcular a soma de qualquer intervalo \\( [i, j] \\) como:</p> \\[ range(i, j) = prefix[j] - prefix[i - 1] \\] <p>Pois:</p> \\[ range(i, j) = prefix[j] - prefix[i - 1] \\] \\[ = (a_1 + a_2 + \\ldots + a_{j-1} + a_j) - (a_1 + a_2 + \\ldots + a_{i-1}) \\] \\[ = ((a_1 + a_2 + \\ldots + a_{i-1}) + (a_i + a_{i+1} + \\ldots + a_{j-1} + a_j)) - (a_1 + a_2 + \\ldots + a_{i-1}) \\] \\[ = (a_i + a_{i+1} + \\ldots + a_{j-1} + a_j) + (a_1 + a_2 + \\ldots + a_{i-1}) - (a_1 + a_2 + \\ldots + a_{i-1}) \\] \\[ = a_i + a_{i+1} + \\ldots + a_{j-1} + a_j \\]"},{"location":"start/prefixsum/#codigo","title":"C\u00f3digo","text":"<p>Esse c\u00f3digo \u00e9 um exemplo de como implementar a t\u00e9cnica de prefixo para a soma. Assim, podemos calcular o range de \\( i \\) at\u00e9 \\( j \\) como:</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin &gt;&gt; n &gt;&gt; q;\n    vector&lt;int&gt; prefix(n + 1);\n\n    // Para evitar o caso de ind\u00edce negativo em\n    // prefix[i-1], indexaremos o array a partir de 1\n    prefix[0] = 0;\n\n    // O(n)\n    for (int i = 1; i &lt;= n; i++) {\n        int x;\n        cin &gt;&gt; x;\n        prefix[i] = prefix[i - 1] + x;\n    }\n\n    // O(q)\n    while (q--) {\n        int l, r;\n        cin &gt;&gt; l &gt;&gt; r;\n        cout &lt;&lt; prefix[r] - prefix[l - 1] &lt;&lt; '\\n';\n    }\n}\n</code></pre>"},{"location":"start/prefixsum/#outras-estruturas-algebricas","title":"Outras estruturas alg\u00e9bricas","text":"<p>Imagine que para resolver certo problema, voc\u00ea precise realizar os c\u00e1lculo de um range de um array utilizando uma opera\u00e7\u00e3o que n\u00e3o seja a de soma, como o produto ou bitwise XOR. Nessa se\u00e7\u00e3o, vamos ver como podemos generalizar o conceito de soma de prefixo para outras opera\u00e7\u00f5es e verificar se podemos ou n\u00e3o utilizar a t\u00e9cnica.</p> <p>Para isso, a rigor matem\u00e1tico, \u00e9 necess\u00e1rio que dado um conjunto \\( G \\) e uma opera\u00e7\u00e3o \\( \\star \\), \\( (G, \\star) \\) seja um grupo.</p>"},{"location":"start/prefixsum/#propriedades-de-um-grupo","title":"Propriedades de um grupo","text":"<p>\\( (G, \\star) \\) \u00e9 um grupo se, e somente se, satisfaz as seguintes propriedades:</p>"},{"location":"start/prefixsum/#fechamento","title":"Fechamento","text":"<p>Operar quaisquer dois elementos de \\( G \\) com \\( \\star \\) deve resultar em um elemento de \\( G \\)</p> \\[ \\forall x, y \\in G, x \\star y \\in G \\]"},{"location":"start/prefixsum/#associatividade","title":"Associatividade","text":"<p>A opera\u00e7\u00e3o \\( \\star \\) deve ser associativa, ou seja, a ordem de aplica\u00e7\u00e3o da opera\u00e7\u00e3o entre quaisquer tr\u00eas elementos n\u00e3o importa</p> \\[ \\forall x, y, z \\in G, (x \\star y) \\star z = x \\star (y \\star z) \\]"},{"location":"start/prefixsum/#elemento-neutro","title":"Elemento neutro","text":"<p>Deve existir um elemento \\( e \\) em \\( G \\), tal que, operar qualquer elemento \\( x \\) em \\( G \\) com \\( e \\) resulta em \\( x \\)</p> \\[ \\forall x \\in G, \\exists e \\in G : x \\star e = e \\star x = x \\]"},{"location":"start/prefixsum/#inverso","title":"Inverso","text":"<p>Deve existir um elemento \\( y \\) em \\( G \\) para cada elemento \\( x \\) em \\( G \\), tal que, operar \\( x \\) com \\( y \\) resulta no elemento neutro \\( e \\)</p> \\[ \\forall x \\in G, \\exists y \\in G : x \\star y = y \\star x = e \\] <p>Dessa forma, poderemos utilizar todo o conhecimento adquirido acima. Pois, seja:</p> \\[ prefix[i] = a_1 \\star a_2 \\star \\ldots \\star a_{i-1} \\star a_i \\] <p>Observe que \\( prefix[i] \\) pertence a \\( G \\) pela propriedade de fechamento. Dessa forma:</p> \\[ prefix[i] = prefix[i-1] \\star a_i \\] <p>Como \\( prefix[i] \\) pertence a \\( G \\), logo \\( prefix[i] \\) possui um elemento inverso, seja \\( prefix[i]^{-1} \\) esse elemento. Assim, podemos definir a opera\u00e7\u00e3o de range como:</p> \\[ range(i, j) = prefix[i-1]^{-1} \\star prefix[j] \\] <p>Pois:</p> \\[ range(i, j) = (a_1 \\star a_2 \\star \\ldots \\star a_{i-1})^{-1} \\star (a_1 \\star a_2 \\star \\ldots \\star a_{j-1} \\star a_j) \\] \\[ = (a_1 \\star a_2 \\star \\ldots \\star a_{i-1})^{-1} \\star (a_1 \\star a_2 \\star \\ldots \\star a_{i-1}) \\star (a_{i} \\star a_{i+1} \\star a_{i+2} \\star \\ldots \\star a_j) \\] \\[ = ((a_1 \\star a_2 \\star \\ldots \\star a_{i-1})^{-1} \\star (a_1 \\star a_2 \\star \\ldots \\star a_{i-1})) \\star (a_{i} \\star a_{i+1} \\star a_{i+2} \\star \\ldots \\star a_j) \\] \\[ = e \\star (a_{i} \\star a_{i+1} \\star a_{i+2} \\star \\ldots \\star a_j) \\] \\[ = a_{i} \\star a_{i+1} \\star a_{i+2} \\star \\ldots \\star a_j \\] <p>Note</p> <ul> <li>Linha 2 e 3: Associatividade</li> <li>Linha 4: Inverso</li> <li>Linha 5: Elemento neutro</li> </ul>"},{"location":"start/prefixsum/#exemplo-da-operacao-de-range","title":"Exemplo da opera\u00e7\u00e3o de range","text":"<p>Tome o array \\( \\{ a_1, a_2, a_3, a_4, a_5 \\} \\), tal que, \\( a_1, a_2, a_3, a_4, a_5 \\in G \\) e \\( (G, \\star) \\) \u00e9 um grupo e deseja calcular o \\( range(3, 5) \\):</p> \\[ range(3, 5) = prefix[2]^{-1} \\star prefix[5] \\] \\[ = (a_1 \\star a_2)^{-1} \\star (a_1 \\star a_2 \\star a_3 \\star a_4 \\star a_5) \\] \\[ = (a_1 \\star a_2)^{-1} \\star (a_1 \\star a_2) \\star (a_3 \\star a_4 \\star a_5) \\] \\[ = ((a_1 \\star a_2)^{-1} \\star (a_1 \\star a_2)) \\star (a_3 \\star a_4 \\star a_5) \\] \\[ = e \\star (a_3 \\star a_4 \\star a_5) \\] \\[ = a_3 \\star a_4 \\star a_5 \\]"},{"location":"start/prefixsum/#exemplo-de-grupos","title":"Exemplo de grupos","text":""},{"location":"start/prefixsum/#soma-nos-reais","title":"Soma nos reais","text":"<p>\\( ( \\mathbb{R}, + ) \\)</p> <ul> <li>Elemento neutro: \\( 0 \\)</li> <li>Inverso: Fun\u00e7\u00e3o de subtra\u00e7\u00e3o</li> </ul>"},{"location":"start/prefixsum/#multiplicacao-nos-inteiros","title":"Multiplica\u00e7\u00e3o nos inteiros","text":"<p>\\( ( \\mathbb{Z}, * ) \\)</p> <ul> <li>Elemento neutro: \\( 1 \\)</li> <li>Inverso: Fun\u00e7\u00e3o de divis\u00e3o</li> </ul>"},{"location":"start/prefixsum/#bitwise-xor-nos-inteiros","title":"Bitwise XOR nos inteiros","text":"<p>\\( ( \\mathbb{Z}, \\oplus ) \\)</p> <ul> <li>Elemento neutro: \\( 0 \\)</li> <li>Inverso: Fun\u00e7\u00e3o de bitwise XOR</li> </ul>"},{"location":"start/prefixsum/#codigo-geral","title":"C\u00f3digo geral","text":"<p>Esse c\u00f3digo \u00e9 um exemplo de como implementar a t\u00e9cnica de prefixo para o produto. Para isso, utilizamos o inverso da multiplica\u00e7\u00e3o, que \u00e9 a divis\u00e3o. Assim, podemos calcular o range de \\( i \\) at\u00e9 \\( j \\) como:</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nvector&lt;double&gt; prefix;\n\ndouble neutro = 1.0;\n// elemento neutro para soma seria:\n// int neutro = 0;\n\ndouble inverso(double x) {\n    return 1.0 / x;\n    // Inverso da soma seria:\n    // return -x;\n}\n\ndouble operacao(double x, double y) {\n    return x * y;\n    // Opera\u00e7\u00e3o de soma seria:\n    // return x + y;\n}\n\ndouble range(int i, int j) {\n    return operacao(inverso(prefix[i - 1]), prefix[j]);\n}\n\nint main() {\n    int n, q;\n    cin &gt;&gt; n &gt;&gt; q;\n    prefix.resize(n + 1);\n    prefix[0] = neutro;\n\n    // O(n)\n    for (int i = 1; i &lt;= n; i++) {\n        double x;\n        cin &gt;&gt; x;\n        prefix[i] = operacao(prefix[i - 1], x);\n    }\n\n    // O(q)\n    while (q--) {\n        int l, r;\n        cin &gt;&gt; l &gt;&gt; r;\n        cout &lt;&lt; range(l, r) &lt;&lt; endl;\n    }\n}\n</code></pre>"},{"location":"start/prefixsum/#problemas-recomendados","title":"Problemas recomendados","text":"<ul> <li>Static Range Sum Queries</li> <li>Range Xor Queries</li> </ul>"},{"location":"start/segtree/","title":"Segment Tree","text":"<p>oi</p>"},{"location":"start/stl/","title":"C++ Standard Template Library (STL)","text":""},{"location":"start/stl/#aula-relacionada-recomendada","title":"Aula Relacionada recomendada:","text":"C\u0155editos: Canal Maratona UFMG."},{"location":"start/stl/#conhecendo-a-stl","title":"Conhecendo a STL:","text":"<p>A Standard Template Library (STL) do C++ \u00e9 um conjunto de classes e fun\u00e7\u00f5es baseadas em templates que implementam estruturas de dados e algoritmos amplamente utilizados, como listas, pilhas, vetores, ordena\u00e7\u00e3o, busca, entre outros. Al\u00e9m disso, ela disponibiliza iteradores e functors, o que simplifica o uso e a integra\u00e7\u00e3o de algoritmos com os containers.</p> <p>Nesta se\u00e7\u00e3o, vamos conhecer as principais estruturas e algoritmos da STL que s\u00e3o usados na programa\u00e7\u00e3o competitiva.</p> <p>As estruturas de dados mais comuns s\u00e3o:</p> Estrutura Descri\u00e7\u00e3o <code>vector</code> Armazena elementos como um array, mas pode alterar seu tamanho dinamicamente. A adi\u00e7\u00e3o e remo\u00e7\u00e3o de elementos geralmente ocorrem no final, e os elementos podem ser acessados por \u00edndice. <code>set</code> Armazena elementos \u00fanicos de forma ordenada (crescente). Elementos n\u00e3o podem ser acessados por \u00edndice. <code>map</code> Armazena elementos em pares \"chave/valor\". Pode ser acessado atrav\u00e9s das chaves, e n\u00e3o pelo \u00edndice. <code>pair</code> Armazena dois valores como um \u00fanico elemento, onde cada valor pode ter um tipo diferente. O acesso aos valores \u00e9 feito por meio de <code>first</code> e <code>second</code>. <code>stack</code> Armazena elementos em uma ordem espec\u00edfica, chamada LIFO (Last In, First Out), onde os elementos podem ser adicionados e removidos apenas do topo. N\u00e3o \u00e9 acess\u00edvel por \u00edndice. <code>list</code> Armazena elementos de forma sequencial, onde cada elemento est\u00e1 ligado ao pr\u00f3ximo. A adi\u00e7\u00e3o e remo\u00e7\u00e3o de elementos podem ser realizadas em ambas as extremidades, mas n\u00e3o \u00e9 acess\u00edvel por \u00edndice. <code>queue</code> Armazena elementos em uma ordem espec\u00edfica, chamada FIFO (First In, First Out), onde os elementos s\u00e3o adicionados no final e removidos da frente. N\u00e3o \u00e9 acess\u00edvel por \u00edndice. <code>deque</code> Armazena elementos em uma fila de duas extremidades (deque), onde os elementos podem ser adicionados e removidos de ambos os lados. Os elementos podem ser acessados por \u00edndice. <p>Os algortimos mais comuns s\u00e3o:</p> Algoritmo Descri\u00e7\u00e3o <code>sort</code> Ordena os elementos em uma estrutura de dados. <code>reverse</code> Inverte a ordem dos elementos em um determinado intervalo. <code>swap</code> Troca os valores de duas vari\u00e1veis."},{"location":"start/stl/#template-basico-para-a-pratica-desta-secao","title":"Template b\u00e1sico para a pr\u00e1tica desta se\u00e7\u00e3o:","text":"<p>Para facilitar nossa prat\u00edca nessa se\u00e7\u00e3o utilizaremos esse template simples para praticar as estruturas:</p> template.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n\n  return 0;\n}\n</code></pre>"},{"location":"start/stl/#include-bitsstdch","title":"<code>#include &lt;bits/stdc++.h&gt;</code>","text":"<p>\u00c9 um arquivo de cabe\u00e7alho que j\u00e1 inclui todas as bibliotecas padr\u00e3o, ou seja, voc\u00ea n\u00e3o precisa dar <code>#include</code> manualmente para cada estrutura de dados ou algoritmo que for usar. Por exemplo, se precisar de <code>vector</code> e <code>set</code>, normalmente teria que incluir <code>#include &lt;vector&gt;</code> e <code>#include &lt;set&gt;</code> separadamente. Com <code>#include &lt;bits/stdc++.h&gt;</code>, tudo isso j\u00e1 vem junto, facilitando o uso e economizando tempo.</p>"},{"location":"start/stl/#using-namespace-std","title":"<code>using namespace std;</code>","text":"<p>O <code>using namespace std;</code> \u00e9 uma diretiva no C++ que permite que voc\u00ea use os elementos da biblioteca padr\u00e3o (std) sem precisar escrever <code>std::</code> antes de cada um deles. Isso facilita a escrita do c\u00f3digo, pois voc\u00ea n\u00e3o precisa digitar <code>std::</code> repetidamente para acessar coisas como <code>cout</code>, <code>cin</code>, <code>vector</code>, entre outros.</p> <p>Por exemplo, se voc\u00ea n\u00e3o usar o <code>using namespace std;</code>, seria necess\u00e1rio escrever <code>std::cout</code>, <code>std::cin</code>, <code>std::vector</code>, etc. Com o <code>using namespace std;</code>, basta escrever <code>cout</code>, <code>cin</code>, <code>vector</code>, e o compilador entender\u00e1 automaticamente que voc\u00ea est\u00e1 se referindo \u00e0 vers\u00e3o padr\u00e3o dessas fun\u00e7\u00f5es e estruturas.</p>"},{"location":"start/stl/#estruturas-de-dados","title":"Estruturas de Dados:","text":"<p>Em cada um dos links abaixo, voc\u00ea encontra refer\u00eancias que ensinam a utilizar cada uma das estruturas.</p> <ul> <li><code>vector</code>: https://www.geeksforgeeks.org/vector-in-cpp-stl/</li> <li><code>set</code>: https://www.geeksforgeeks.org/set-in-cpp-stl/</li> <li><code>map</code>: https://www.geeksforgeeks.org/set-in-cpp-stl/</li> <li><code>pair</code>: https://www.geeksforgeeks.org/pair-in-cpp-stl/</li> <li><code>stack</code>: https://www.geeksforgeeks.org/stack-in-cpp-stl/</li> <li><code>list</code>: https://www.geeksforgeeks.org/list-cpp-stl/</li> <li><code>queue</code>: https://www.geeksforgeeks.org/queue-cpp-stl/</li> <li><code>deque</code>:  https://www.geeksforgeeks.org/deque-cpp-stl/</li> </ul>"},{"location":"start/stl/#algoritmos","title":"Algoritmos:","text":"<p>Em cada um dos links abaixo, voc\u00ea encontra refer\u00eancias que ensinam a utilizar cada um dos algoritmos.</p> <ul> <li><code>sort</code>: https://www.geeksforgeeks.org/sort-c-stl/</li> <li><code>reverse</code>: https://www.geeksforgeeks.org/stdreverse-in-c/</li> <li><code>swap</code>: https://www.geeksforgeeks.org/swap-in-cpp/</li> </ul>"},{"location":"start/stl/#lista-de-exercicios","title":"Lista de Exerc\u00edcios:","text":"<ul> <li>CSES - Distinct Numbers </li> </ul>"},{"location":"start/twopointers/","title":"Two Pointers","text":""},{"location":"start/dp/intro/","title":"Introdu\u00e7\u00e3o","text":""},{"location":"start/dp/knapsack/","title":"Knapsack DP","text":""},{"location":"start/dp/lcs/","title":"LCS","text":""},{"location":"start/dp/paths/","title":"Caminhos em Matrizes","text":""},{"location":"start/graphs-intro/classes/","title":"Classes","text":"<p>Essa se\u00e7\u00e3o apresenta as principais classes de grafos.</p>"},{"location":"start/graphs-intro/classes/#arvore","title":"\u00c1rvore","text":"<p>Uma \u00e1rvore \u00e9 um tipo de grafo geralmente utilizado para representar uma hierarquia entre os v\u00e9rtices. O v\u00e9rtice mais acima \u00e9 chamado de Raiz, e a altura de cada v\u00e9rtice representa a sua dist\u00e2ncia at\u00e9 a raiz. Um v\u00e9rtice que n\u00e3o tem filhos \u00e9 chamado de Folha. Chamamos de floresta um grafo em que todas suas componentes conexas s\u00e3o uma \u00e1rvore.</p> <p>\u00c1rvore cuja raiz \u00e9 o vertice A, e as folhas s\u00e3o os v\u00e9rtices C, D e F.</p> <p>Caracter\u00edsticas de \u00e1rvorre</p> <ul> <li>Um v\u00e9rtice pode ter v\u00e1rios filhos, por\u00e9m tem um \u00fanico pai.</li> <li>Possui exatamente \\(N-1\\) arestas, sendo \\(N\\) o n\u00famero de v\u00e9rtices. </li> <li>Existe apenas um caminho entre dois v\u00e9rtices. </li> <li>N\u00e3o apresenta ciclos </li> </ul>"},{"location":"start/graphs-intro/classes/#grafos-direcionados","title":"Grafos Direcionados","text":"<p>Um grafo direcionado ou orientado \u00e9 um grafo em que suas arestas possuem um sentido. Se um par \\((U,V)\\) pertence ao conjunto \\(E\\) de arestas, ent\u00e3o existe um caminho de \\(U\\) para \\(V\\), mas n\u00e3o necessariamente existe um caminho de \\(V\\) para \\(U\\).</p> <p>Representa\u00e7\u00e3o das arestas</p> <p>No grafo direcionado, as arestas geralmente s\u00e3o representadas por setas. </p> \\[ \\begin{aligned} &amp;\\hphantom{..............} V = \\{A, B, C, D\\} \\\\ &amp;E = \\{(A, B),\\ (A, C),\\ (B, C),\\ (D, B),\\ (C, D)\\} \\end{aligned} \\] <p>No grafo acima, existe uma aresta entre os v\u00e9rtices \\(A\\) e \\(C\\), no entando n\u00e3o h\u00e1 um caminho que saia de \\(C\\) e chegue em \\(A\\). Em contrapartida, existe a aresta \\((B,C)\\) com um caminho saindo de \\(C\\) que chega em \\(B\\), passando pelo v\u00e9rtice \\(D\\).</p>"},{"location":"start/graphs-intro/classes/#grafo-ponderado","title":"Grafo Ponderado","text":"<p>Um grafo ponderado \u00e9 um grafo que cada aresta possui um peso, ou seja, um valor. Formalmente, existe uma fun\u00e7\u00e3o \\(W\\) que relaciona o conjunto de arestas \\(E\\) do grafo aos numeros reais \\(\\mathbb{R}\\). Os pesos podem representar, por exemplo, custo ou dist\u00e2ncia entre os v\u00e9rtices.</p> \\[ \\begin{aligned}     W(A,B) = 1 \\\\     W(B,C) = 2 \\\\     W(B,D) = 3 \\\\     W(C,D) = 4 \\\\     W(A,C) = 5 \\end{aligned} \\]"},{"location":"start/graphs-intro/introduction/","title":"Introdu\u00e7\u00e3o","text":"<p>Essa se\u00e7\u00e3o tem o intuito de apresentar uma introdu\u00e7\u00e3o \u00e0 Teoria dos Grafos.</p>"},{"location":"start/graphs-intro/introduction/#definicao","title":"Defini\u00e7\u00e3o","text":"<p>Um grafo \u00e9 uma estrutura representada por um par ordenado \\(G = (V, E)\\), em que \\(V\\) \u00e9 o conjunto de v\u00e9rtices e \\(E\\) \u00e9 o conjunto de arestas. Eles podem ser utilizados para representar rela\u00e7\u00f5es entre os v\u00e9rtices, atrav\u00e9s do uso das arestas. Por exemplo, os v\u00e9rtices podem ser vistos como cidades e as arestas como estradas, em que a aresta \\((U,V)\\) existe se h\u00e1 uma estrada entre as cidades \\(U\\) e \\(V\\).</p> <p>Os exemplos dessa se\u00e7\u00e3o ser\u00e3o baseados no seguinte grafo:</p> \\[     V = \\{A, B, C, D\\} \\] \\[     E = \\{             (A, B), (A, C),             (B, C), (B, D),             (C, D)         \\} \\]"},{"location":"start/graphs-intro/introduction/#vizinhanca","title":"Vizinhan\u00e7a","text":"<p>Definimos a vizinhan\u00e7a \\(N\\) de um v\u00e9rtice \\(V\\) como o conjunto de v\u00e9rtices que est\u00e3o ligados diretamente a \\(V\\) atrav\u00e9s de uma aresta. Em grafos direcionados, se temos a aresta \\((U,V)\\), ent\u00e3o \\(V\\in N(U)\\) e \\(U\\notin N(V)\\).  </p> \\[ N(V) = \\{U | (V,U) \\in E\\} \\] \\[ \\begin{aligned} &amp;N(A) = \\{B,C\\} \\\\ &amp;N(B) = \\{A,C,D\\} \\\\ &amp;N(C) = \\{A,B,D\\} \\\\ &amp;N(D) = \\{B,C\\}  \\end{aligned} \\]"},{"location":"start/graphs-intro/introduction/#grau","title":"Grau","text":"<p>O grau de um v\u00e9rtice \\(V\\) \u00e9 o n\u00famero de arestas que incidem em \\(V\\). Se existe uma aresta que liga um v\u00e9rtice nele mesmo (loops), ela conta duas vezes em seu grau.  Em grafos direcionados, temos dois tipos de grau: de entrada e saida, que representam, respectivamente, o n\u00famero de arestas que entram e saem no v\u00e9rtice.</p> \\[     Deg(V) = |N(V)| + loops \\] \\[ \\begin{aligned} &amp;Deg(A) = 2 \\\\ &amp;Deg(B) = 3 \\\\ &amp;Deg(C) = 3 \\\\ &amp;Deg(D) = 2  \\end{aligned} \\]"},{"location":"start/graphs-intro/representation/","title":"Representa\u00e7\u00e3o","text":"<p>Nessa se\u00e7\u00e3o veremos maneiras de representar um grafo em c\u00f3digo. Os exemplos ser\u00e3o baseados no seguinte grafo:</p>"},{"location":"start/graphs-intro/representation/#matriz-de-adjacencia","title":"Matriz de Adjac\u00eancia","text":"<p>Representamos o grafo como uma matriz \\(M\\) de dimens\u00e3o \\(N*N\\), sendo \\(N\\) o n\u00famero de v\u00e9rtices. Podemos descobrir se existe uma aresta entre \\(U\\) e \\(V\\) em tempo \\(O(1)\\) apenas olhando para \\(M[U][V]\\). No entanto, a complexidade de  mem\u00f3ria \u00e9 \\(O(N^2)\\), o que pode ser invi\u00e1vel se o grafo tiver muitos v\u00e9rtices e poucas arestas (Grafos Esparsos).</p> \\[ M[U][V] = \\begin{cases} 0, &amp; (U,V) \\notin E \\\\ 1, &amp; (U,V) \\in E \\end{cases} \\] <p>Exemplo da matriz de Adjac\u00eancia do grafo desenhado anteriormente.</p>"},{"location":"start/graphs-intro/representation/#lista-de-adjacencia","title":"Lista de Adjac\u00eancia","text":"<p>Para todo v\u00e9rtice \\(U\\) do grafo, fazemos uma estrutura que armazena todo v\u00e9rtice \\(V\\in N(U)\\), ou seja, todo v\u00e9rtice \\(V\\) na vizinhan\u00e7a de \\(U\\). A complexidade de tempo para determinar se existe uma aresta entre os v\u00e9rtices \\(U\\) e \\(V\\) depender\u00e1 da estrutura utilizada. Em grafos esparsos, a mem\u00f3ria utilizada \u00e9 consideravelmente menor do que em matrizes de adjacencia.</p> <p>Exemplo da lista de Adjac\u00eancia do grafo desenhado anteriormente.</p>"},{"location":"start/graphs-intro/min-path/bellmanford/","title":"Bellman-Ford","text":"<p>oi</p>"},{"location":"start/graphs-intro/min-path/dijkstra/","title":"Dijkstra","text":""},{"location":"start/graphs-intro/min-path/floydwarshall/","title":"Floyd-Warshall","text":""},{"location":"start/graphs-intro/search/bfs/","title":"Breadth First Search (BFS)","text":""},{"location":"start/graphs-intro/search/dfs/","title":"Depth First Search (DFS)","text":""},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/category/test/","title":"test","text":""},{"location":"blog/category/contests/","title":"Contests","text":""}]}